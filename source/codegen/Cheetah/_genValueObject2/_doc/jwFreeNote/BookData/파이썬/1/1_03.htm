<HTML><HEAD><META http-equiv=Content-Type content="text/html; charset=euc-kr">
<style type="text/css">
<!--
BODY,TD,SELECT,input,DIV,form,TEXTAREA,option {font-size:9pt; font-family:verdana;color:333333}
A:link {color:#4077a0;text-decoration:none;font-weight: bold}
A:visited {color:#4077a0;text-decoration:none;font-weight: bold}
A:hover{color:#990000;text-decoration:none;font-weight: bold}
--></style></HEAD>
<BODY>
<table cellSpacing=1 cellPadding=4 width=500 bgColor=#3c62c6 border=0>
  <tr>
    <td width=600>
      <div><STRONG><FONT color=#ffffff>▶제목/참고</FONT></STRONG> </div></td></tr>
  <tr bgColor=#ffffff>
    <td>
      <div></div>
      <DIV>Title: </DIV>      
      <div>&nbsp;</div>
      <DIV>&nbsp;</DIV>
      <DIV>From: </DIV>
    </td></tr></table>
<div><A 
href="http://rupert.cs.montana.edu/~jjc/easytut/korean/node15.html">http://rupert.cs.montana.edu/~jjc/easytut/korean/node15.html</A></div>
<DIV>
<H1><A name=SECTION001500000000000000000>리스트에 대하여 더 자세히</A> </H1>우리는 이미 리스트가 어떻게 
사용될 수 있는지 살펴본 바 있다. 이제 여러분은 좀더 배경지식을 같게 되었으므로 나는 리스트에 대하여 좀 더 자세하게 들어가 보려고 한다. 
먼저 리스트에서 요소를 획득하는 더 많은 방법을 살펴볼 것이다. 그리고 우리는 그것들을 복사하는 것에 대하여 논의할 것이다. 
<P>여기에 지표를 사용하여 리스트의 구성요소에 접근하는 약간의 예제가 있다: <PRE>&gt;&gt;&gt; list = ['zero','one','two','three','four','five']
&gt;&gt;&gt; list[0]
'zero'
&gt;&gt;&gt; list[4]
'four'
&gt;&gt;&gt; list[5]
'five'
</PRE>이러한 모든 예제들은 여러분에게 매우 친숙하게 보여야만 한다. 여러분이 리스트에서 첫 번째 항목을 원한다면 단지 지표 0을 살펴보라. 
두 번째 항목은 지표 1 이고 그런식으로 리스트의 마지막까지 간다. 그렇지만 여러분이 리스트의 마지막 항목을 원한다면 어떻게 할까? 하나의 
방법은 '<CODE>list[len(list)-1]</CODE>'와 같이 <CODE>len</CODE> 함수를 사용하는 것이다. 
<CODE>len</CODE>함수가 항상 마지막 지표 더하기 1 값을 반환해 주므로 이것은 잘 작동한다. 마지막으로부터 두 번째는 그러면 
<CODE>list[len(list)-2]</CODE> 이 될 것이다. 이것을 위한 더 쉬운 방법이 있다. 파이썬에서 가장 마지막 항목은 항상 
'index-1' 이다. 마지막에서 두번째는 'index -2' 이다. 등등. 여기에 예제를 더 보인다면: <PRE>&gt;&gt;&gt; list[len(list)-1]
'five'
&gt;&gt;&gt; list[len(list)-2]
'four'
&gt;&gt;&gt; list[-1]
'five'
&gt;&gt;&gt; list[-2]
'four'
&gt;&gt;&gt; list[-6]
'zero'
</PRE>이렇게 리스트의 어떤 항목도 두 가지 방법으로 지표화 될 수 있다 : 앞으로 부터 그리고 뒤로 부터 
<P>리스트의 부분으로 들어가는 또 다른 유용한 방법은 썰기이다. 여기에 여러분에게 썰기가 무엇에 유용한지 아이디어를 제공하는 또 다른 예제가 
있다.: <PRE>&gt;&gt;&gt; list = [0,'Fred',2,'S.P.A.M.','Stocking',42,"Jack","Jill"]
&gt;&gt;&gt; list[0]
0
&gt;&gt;&gt; list[7]
'Jill'
&gt;&gt;&gt; list[0:8]
[0, 'Fred', 2, 'S.P.A.M.', 'Stocking', 42, 'Jack', 'Jill']
&gt;&gt;&gt; list[2:4]
[2, 'S.P.A.M.']
&gt;&gt;&gt; list[4:7]
['Stocking', 42, 'Jack']
&gt;&gt;&gt; list[1:5]
['Fred', 2, 'S.P.A.M.', 'Stocking']
</PRE>썰기는 리스트의 부분을 반환하는데 사용된다. 썰기 연산자는 
<CODE>list[first_index:following_index]</CODE>의 형태로 사용된다. 썰기는 
<CODE>first_index</CODE>로부터 <CODE>following_index</CODE>앞의 지표까지 실행된다. 여러분은 지표화 
형태 두 가지 모두를 사용할 수 있다: <PRE>&gt;&gt;&gt; list[-4:-2]
['Stocking', 42]
&gt;&gt;&gt; list[-4]
'Stocking'
&gt;&gt;&gt; list[-4:6]
['Stocking', 42]
</PRE>썰기에 대한 또 다른 꼼수는 지표를 생략하는 것이다. 만약 첫 번째 지표가 생략되면 리스트의 처음이라고 가정된다. 만약 다음의 지표가 
생략되면 그 리스트의 나머지 전체라고 가정된다. 여기에 약간의 예제가 있다: <PRE>&gt;&gt;&gt; list[:2]
[0, 'Fred']
&gt;&gt;&gt; list[-2:]
['Jack', 'Jill']
&gt;&gt;&gt; list[:3]
[0, 'Fred', 2]
&gt;&gt;&gt; list[:-5]
[0, 'Fred', 2]
</PRE>여기에 하나의 프로그램 예제가 있다. (여러분이 원한다면 시를 정의하는 형태로 복사하고 붙여넣어라): <PRE>poem = ["&lt;B&gt;","Jack","and","Jill","&lt;/B&gt;","went","up","the","hill","to","&lt;B&gt;",\
"fetch","a","pail","of","&lt;/B&gt;","water.","Jack","fell","&lt;B&gt;","down","and",\
"broke","&lt;/B&gt;","his","crown","and","&lt;B&gt;","Jill","came","&lt;/B&gt;","tumbling",\
"after"]

def get_bolds(list):
        true = 1
        false = 0
        ## is_bold tells whether or not the we are currently looking at
        ## a bold section of text.
        is_bold = false
        ## start_block is the index of the start of either an unbolded
        ## segment of text or a bolded segment.
        start_block = 0
        for index in range(len(list)):
                ##Handle a starting of bold text
                if list[index] == "&lt;B&gt;":
                        if is_bold:
                                print "Error:  Extra Bold"
                        ##print "Not Bold:",list[start_block:index]
                        is_bold = true
                        start_block = index+1
                ##Handle end of bold text
                if list[index] == "&lt;/B&gt;":
                        if not is_bold:
                                print "Error: Extra Close Bold"
                        print "Bold [",start_block,":",index,"] ",\
                        list[start_block:index]
                        is_bold = false
                        start_block = index+1

get_bolds(poem)
</PRE>출력을 보인다면: <PRE>Bold [ 1 : 4 ]  ['Jack', 'and', 'Jill']
Bold [ 11 : 15 ]  ['fetch', 'a', 'pail', 'of']
Bold [ 20 : 23 ]  ['down', 'and', 'broke']
Bold [ 28 : 30 ]  ['Jill', 'came']
</PRE>
<P><CODE>get_bold</CODE>함수는 하나의 리스트를 불러들여 단어와 토큰으로 분리한다. 그 함수가 찾는 토큰은 굵은 글씨체의 
시작을 나타내는 '<CODE>&lt;B&gt;</CODE>'와 굵은 글씨체의 마지막을 나타내는 ' <CODE>&lt;\B&gt;</CODE>' 
이다. 그 함수 <CODE>get_bold</CODE>는 진행하면서 처음과 마지막 토큰을 탐색한다. 
<P>리스트의 다음 사양은 그들을 복사하는 것이다. 여러분이 다음과 같이 간단한 어떤 것을 시도해 본다면: <PRE>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; print b
[1, 2, 3]
&gt;&gt;&gt; b[1] = 10
&gt;&gt;&gt; print b
[1, 10, 3]
&gt;&gt;&gt; print a
[1, 10, 3]
</PRE>이것은 아마도 놀라워 보일 것이다. 왜냐하면 <TT>b</TT> 에 대한 변경이 <TT>a</TT> 를 변경한 결과가 되었기 
때문이다. 상황은 '<CODE>b = a</CODE>' 서술문이 <TT>b</TT> 를 <TT>a</TT> 에 대한 <EM>참조점</EM>으로 
만들었기 때문이다. 이것이 뜻하는 바는 <TT>b</TT>를 <TT>a</TT>의 다른 이름으로 생각해도 좋다는 것을 의미한다. 그러므로 
<TT>b</TT>에 대한 어떠한 변경도 <TT>a</TT> 를 역시 변경시킨다. 그렇지만 <TT>b</TT> 전체에다 할당하는 함수를 
사용하면서 <TT>a</TT> 를 변경하지 마라: <PRE>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b = b*2
&gt;&gt;&gt; print a
[1, 2, 3]
&gt;&gt;&gt; print b
[1, 2, 3, 1, 2, 3]
</PRE>이 경우에는 '<CODE>b = b*2</CODE>'서술문이 복사본 하나를 생성하므로 <TT>b</TT> 는 더 이상 
<TT>a</TT>에 대한 참조점이 아니다. 기본적으로 여러분이 '<CODE>whole_list_b = whole_list_a</CODE>'와 
같은 서술문을 가지고 있다면 여러분은 하나의 참조를 생성하고 있는 것이다. 여러분이 리스트를 인수로서 함수에 넘길 때에도 여러분은 역시 주소점을 
생성하고 있는 것이다. <CODE>whole_list_b</CODE> 에 대한 부차적인 변경은 원래의 리스트를 변경할 것이다. 대부분의 경우에 
여러분은 이러한 불일치에 대하여 걱정할 필요가 없다. 그렇지만 여러분은 리스트의 복사본을 가질 필요가 있을 때 실제로 하나의 복사본을 생성했는지 
확실하게 해야만 한다. 
<P>리스트를 복사하는 여러 방법들이 있다. 대부분의 경우에 있어서 잘 작동하는 가장 간단한 것은 썰기(slice) 연산자이다: <PRE>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; b[1] = 10
&gt;&gt;&gt; print a
[1, 2, 3]
&gt;&gt;&gt; print b
[1, 10, 3]
</PRE>썰기 "<TT>[:]</TT>"는 리스트에 대한 복사본을 생성한다. 그렇지만 바깥쪽 리스트만 복사한다. 만약 그 리스트가 리스트를 
포함하고 있다면 안 쪽의 리스트도 역시 복사될 필요가 있다. 여러분은 그것을 수동으로 할 수도 있게지만, 파이썬은 이미 그런 일을 하는 모둘을 
포함하고 있다. 여러분은 <TT>copy</TT> 모듈에 있는 <TT>deepcopy</TT> 함수를 사용할 수 있다: <PRE>&gt;&gt;&gt; import copy
&gt;&gt;&gt; a = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; b[0][1] = 10
&gt;&gt;&gt; c[1][1] = 12
&gt;&gt;&gt; print a
[[1, 10, 3], [4, 5, 6]]
&gt;&gt;&gt; print b
[[1, 10, 3], [4, 5, 6]]
&gt;&gt;&gt; print c
[[1, 2, 3], [4, 12, 6]]
</PRE>무엇보다도 <TT>a</TT> 는 배열의 배열이라는 것을 주목하라. 안쪽의 배열은 썰기 연산자로 정확하게 복사되지 않는다. 그렇지만 
<TT>deepcopy</TT>로 <TT>c</TT>는 정확하게 복사된다. 잠-깐 : 이런게 의미가 있는가? 
<P>지금까지 여러분은 아마도 왜 참조가 사용되는지 도대체 이해가 안갈 것이다? 기본적인 이유는 속력 때문이다. 수천의 요소들 모두를 복사하는 
것 보다는 그것들을 참조하는 편이 훨씬 더 빠르다. 그러지 않아야 할때 데이타가 변하는 괴이한 문제를 여러분이 가지더라도 참조에 관하여 여러분은 
단지 이 사실만은 기억하라. </P></DIV>
</BODY></HTML>
