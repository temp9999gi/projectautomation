<HTML><HEAD><META http-equiv=Content-Type content="text/html; charset=euc-kr">
<style type="text/css">
<!--
BODY,TD,SELECT,input,DIV,form,TEXTAREA,option {font-size:9pt; font-family:verdana;color:333333}
A:link {color:#4077a0;text-decoration:none;font-weight: bold}
A:visited {color:#4077a0;text-decoration:none;font-weight: bold}
A:hover{color:#990000;text-decoration:none;font-weight: bold}
--></style></HEAD>
<BODY>
<table cellSpacing=1 cellPadding=4 width=500 bgColor=#3c62c6 border=0>
  <tr>
    <td width=600>
      <div><STRONG><FONT color=#ffffff>▶제목/참고</FONT></STRONG> </div></td></tr>
  <tr bgColor=#ffffff>
    <td>
      <div></div>
      <DIV>Title: </DIV>      
      <div>&nbsp;</div>
      <DIV>&nbsp;</DIV>
      <DIV>From: </DIV>
    </td></tr></table>
<div><A 
href="http://home.paran.com/johnsonj/etc/Regular%20Expression%20HOWTO.htm#SECTION000310000000000000000">http://home.paran.com/johnsonj/etc/Regular%20Expression%20HOWTO.htm#SECTION000310000000000000000</A></div>
<DIV>
<DIV class=titlepage>
<CENTER>
<H1>정규 표현식 HOWTO</H1>
<P><B><FONT size=+2>쿠클링(A.M. Kuchling)</FONT></B></P>
<P><SPAN class=email><FONT face=Arial>amk@amk.ca</FONT></SPAN></P>
<P>한글판 johnsonj 2003.11.25</P></CENTER></DIV>
<P>
<H3>요약:</H3>
<DIV class=ABSTRACT>이 문서는 파이썬에서 <TT class=module>re</TT> 모듈을 가지고 정규 표현식을 사용하는 법에 
대한 개론 튜토리얼이다. 라이브러리 참조서보다 좀 더 부드럽게 소개한다. 
<P>이 문서는 <A class=url href="http://www.amk.ca/python/howto/regex/"><U><FONT 
face=Arial color=#0000bb>http://www.amk.ca/python/howto</FONT></U></A>에서 얻을 수 
있다. 
<P></P></DIV>
<P>
<P><BR><BR>
<H2><A name=SECTION000100000000000000000>내용</A> </H2><!--Table of Contents-->
<UL class=TofC>
  <LI><A href="#SECTION000200000000000000000"><U><FONT color=#0000bb>1 들어가는 
  말</FONT></U></A> 
  <LI><A href="#SECTION000300000000000000000"><U><FONT color=#0000bb>2 간단한 
  패턴</FONT></U></A> 
  <UL>
    <LI><A href="#SECTION000310000000000000000"><U><FONT color=#0000bb>2.1 문자에 
    일치하기</FONT></U></A> 
    <LI><A href="#SECTION000320000000000000000"><U><FONT color=#0000bb>2.2 작업 
    반복하기</FONT></U></A> </LI></UL>
  <LI><A href="#SECTION000400000000000000000"><U><FONT color=#0000bb>3 정규 표현식의 
  사용</FONT></U></A> 
  <UL>
    <LI><A href="#SECTION000410000000000000000"><U><FONT color=#0000bb>3.1 정규 
    표현식 컴파일</FONT></U></A> 
    <LI><A href="#SECTION000420000000000000000"><U><FONT color=#0000bb>3.2 골치아픈 
    역사선</FONT></U></A> 
    <LI><A href="#SECTION000430000000000000000"><U><FONT color=#0000bb>3.3 일치시켜 
    보기</FONT></U></A> 
    <LI><A href="#SECTION000440000000000000000"><U><FONT color=#0000bb>3.4 
    모듈-수준의 함수</FONT></U></A> 
    <LI><A href="#SECTION000450000000000000000"><U><FONT color=#0000bb>3.5 컴파일 
    표식</FONT></U></A> </LI></UL>
  <LI><A href="#SECTION000500000000000000000"><U><FONT color=#0000bb>4 더욱 강력한 
  패턴</FONT></U></A> 
  <UL>
    <LI><A href="#SECTION000510000000000000000"><U><FONT color=#0000bb>4.1 메타문자를 
    더 자세히</FONT></U></A> 
    <LI><A href="#SECTION000520000000000000000"><U><FONT color=#0000bb>4.2 
    그룹짓기</FONT></U></A> 
    <LI><A href="#SECTION000530000000000000000"><U><FONT color=#0000bb>4.3 비-나포 
    그룹과 이름붙은 그룹</FONT></U></A> 
    <LI><A href="#SECTION000540000000000000000"><U><FONT color=#0000bb>4.4 내다보기 
    선언(Lookahead Assertions)</FONT></U></A> </LI></UL>
  <LI><A href="#SECTION000600000000000000000"><U><FONT color=#0000bb>5 문자열 
  변경하기</FONT></U></A> 
  <UL>
    <LI><A href="#SECTION000610000000000000000"><U><FONT color=#0000bb>5.1 문자열 
    가르기</FONT></U></A> 
    <LI><A href="#SECTION000620000000000000000"><U><FONT color=#0000bb>5.2 탐색과 
    교체</FONT></U></A> </LI></UL>
  <LI><A href="#SECTION000700000000000000000"><U><FONT color=#0000bb>6 일반적인 
  문제들</FONT></U></A> 
  <UL>
    <LI><A href="#SECTION000710000000000000000"><U><FONT color=#0000bb>6.1 문자열 
    메쏘드를 사용하자</FONT></U></A> 
    <LI><A href="#SECTION000720000000000000000"><U><FONT color=#0000bb>6.2 
    match() 대 search()</FONT></U></A> 
    <LI><A href="#SECTION000730000000000000000"><U><FONT color=#0000bb>6.3 탐욕적 
    탐색 대 비-탐욕적 탐색</FONT></U></A> 
    <LI><A href="#SECTION000740000000000000000"><U><FONT color=#0000bb>6.4 
    re.VERBOSE를 사용하지 않으면</FONT></U></A> </LI></UL>
  <LI><A href="#SECTION000800000000000000000"><U><FONT color=#0000bb>7 
  되먹임</FONT></U></A> 
  <LI><A href="#SECTION000900000000000000000"><U><FONT color=#0000bb>이 문서에 대하여 
  ...</FONT></U></A> </LI></UL><!--End of Table of Contents-->
<P>
<H1><A name=SECTION000200000000000000000>1 들어가는 말</A> </H1>
<P><TT class=module>re</TT> 모듈이 파이썬 1.5에 추가되어, 펄-스타일의 정규 표현식 패턴을 제공한다. 이전 버전의 
파이썬에서는 <TT class=module>regex</TT> 모듈이 따라왔는데, 이는 이맥스-스타일의 패턴을 제공한다. 이맥스-스타일의 패턴은 
약간 읽기가 더 어렵고 그렇게 많은 특징을 제공하지 않으므로, 새로운 코드를 작성할 때 <TT class=module>regex</TT> 모듈을 
사용해야 할 이유가 별로 없다. 비록 예전 코드에서는 사용하는 것을 마주할 수도 있겠지만 말이다. 
<P>정규 표현식(RE)은 본질적으로, 작고 고도로 전문화된 프로그래밍 언어로서 파이썬에 임베드 되어서 <TT 
class=module>re</TT> 모듈을 통하여 사용할 수 있다. 이 작은 언어를 사용하면, 일치시키고 싶은 문자열 집합에 대하여 규칙을 
지정할 수 있다; 이 집합에는 영어 문장이나, 전자우편 주소, 또는 TeX 명령어, 원하는 무엇이든 포함된다. 그러면 이렇게 질문할 수 있다 
``이 문자열이 패턴에 일치하는가?'', 또는 ``이 문자열에서 패턴에 일치하는 것이 있는가?''. RE를 사용하면 또한 문자열을 변경하거나 
여러가지 방식으로 가를 수 있다. 
<P>정규 표현식 패턴은 일련의 바이트코드로 컴파일되고 C로 작성된 일치 엔진에 의해서 실행된다. 수준높게 사용하려면, 이 엔진이 어떻게 주어진 
RE를 실행하는지 주의를 기울여서, 더 빨리 실행되는 바이트코드를 생산하도록 RE를 작성할 필요가 있다. 최적화는 이 일치 엔진의 내부에 대해서 
잘 알고 있어야 할 필요가 있기 때문에 이 문서에서 다루지 않는다. 
<P>정규 표현식 언어는 상대적으로 작고 제한적이다. 그래서 정규 표현식을 사용한다고 하더라도 모든 문자열 작업이 가능한 것은 아니다. 또 정규 
표현식으로 처리가 <I>가능하지만</I>, 그 표현식이 너무나도 복잡한 작업도 있다. 이런 경우, 파이썬 코드를 작성해서 처리를 하는 것이 더 
좋다; 정교한 정규 표현식보다 파이썬 코드가 느리겠지만, 아마도 더 이해가 쉬울 것이다. 
<P>
<H1><A name=SECTION000300000000000000000>2 간단한 패턴</A> </H1>
<P>먼저 가장 간단한 정규 표현식을 배워보자. 정규 표현식은 문자열 처리에 사용되기 때문에, 가장 일반적인 작업부터 시작하자: 문자열을 
일치시켜 보자. 
<P>정규 표현식 아래에 숨겨진 더 자세한 컴퓨터 공학적 설명이 (결정 그리고 비-결정 유한 오토마타) 필요하면, 컴파일러의 작성에 관한 
교과서를 아무거나 하나 참조하자. 
<P>
<H2><A name=SECTION000310000000000000000>2.1 문자 일치시키기</A> </H2>
<P>대부분의 문자와 기호는 그냥 자신을 일치시킨다. 예를 들어, 정규 표현식 <TT class=regexp>test</TT>는 문자열 "<TT 
class=samp>test</TT>"에 정확하게 일치한다. (대소문자-구분 모드를 활성화하면 이 RE를 "<TT 
class=samp>Test</TT>"나 "<TT class=samp>TEST</TT>"에도 일치시킬 수 있다; 이에 관해서는 나중에 더 자세히 
다룬다.) 
<P>이 규칙에는 예외가 몇가지 있다; 어떤 문자들은 특별해서, 자신과 일치하지 않는다. 대신에, 그런 문자들은 무언가 정상을 벗어난 어떤 
것들이 일치해야 한다는 것을 나타내거나, 또는 반복함으로써 RE의 다른 부분에 영향을 미친다. 이 문서의 대부분은 다양한 메타문자들과 그 
문자들이 하는 역할을 논의한다. 
<P>다음은 메타문자의 완벽한 목록이다; 그 의미를 지금부터 다루어 보겠다. 
<P>
<DIV class=verbatim><PRE>. ^ $ * + ? { [ ] \ | ( )
</PRE></DIV>
<P>살펴 볼 첫 번째 메타문자는 "<TT class=samp>[</TT>" 그리고 "<TT class=samp>]</TT>"이다. 이 
메타문자는 문자 부류를 지정하는데 사용되는데, 문자 부류란 일치시키고 싶은 문자 집합이다. 문자들은 따로따로 나열될 수 있다. 또는 일정 범위의 
문자들을 나타내려면 문자 두 개를 주고 그 사이를 "<TT class=character>-</TT>"로 가르면 된다. 예를 들면, <TT 
class=regexp>[abc]</TT>는 다음 "<TT class=samp>a</TT>", "<TT class=samp>b</TT>", 또는 
"<TT class=samp>c</TT>" 어느 문자와도 일치한다; 이는 <TT class=regexp>[a-c]</TT>과 동일하며, 범위를 
사용해서 같은 문자 집합을 표현한다. 오직 소문자와만 일치시키고 싶으면, RE는 <TT class=regexp>[a-z]</TT>와 같이 된다. 

<P>메타문자는 부류안에서는 작용하지 않는다. 예를 들어, <TT class=regexp>[akm$]</TT>는 "<TT 
class=character>a</TT>", "<TT class=character>k</TT>", "<TT 
class=character>m</TT>", 또는 "<TT class=character>$</TT>"의 어느 문자와도 일치한다; 일반적으로 
"<TT class=character>$</TT>"는 메타문자이지만, 문자 부류 안에서는 그 특별한 본성을 잃는다. 
<P><I class=dfn>여집합</I>을 지정해서 범위 안에 없는 문자에도 일치시킬 수 있다. 이는 부류에서 첫 문자로 "<TT 
class=character>^</TT>"를 포함하여 나타낸다; 다른 위치에서 "<TT class=character>^</TT>"가 나타나면 
그냥 "<TT class=character>^</TT>" 문자에 일치된다. 예를 들어, <CODE>[^5]</CODE>는 "<TT 
class=character>5</TT>"를 제외하고 어떤 문자에도 일치한다. 
<P>아마도 가장 중요한 메타문자는 역사선 "<TT class=samp>\</TT>"일 것이다. 파이썬 기호문자에서 역사선 뒤에 다양한 문자들이 
따르면서 다양한 특수 연속열을 나타낼 수 있다. 또는 모든 메타문자들을 피시시키는데에도 사용되므로 여전히 패턴으로 일치시킬 수 있다; 예를 
들어, "<TT class=samp>[</TT>" 또는 "<TT class=samp>\</TT>"를 일치시키고 싶으면, 앞에 역사선을 먼저 
두어서 그의 특별한 의미를 없앨 수 있다: <TT class=regexp>\[</TT> 또는 <TT class=regexp>\\</TT>. 
<P>특수 연속열중에 "<TT class=character>\</TT>"로 시작하는 연속열은 자주 쓸모가 있는 문자들이 미리정의된 집합을 
나타내는데, 숫자문자, 기호 집합, 또는 공백이 아닌 어떤 것이든지 된다. 다음과 같이 미리 정의된 특수 연속열을 사용할 수 있다: 
<P>
<DL compact>
  <DT><CODE>\d</CODE> 
  <DD>10진 숫자와 일치한다; 다음 부류와 동일 <TT class=regexp>[0-9]</TT>. 
  <P></P>
  <DT><CODE>\D</CODE> 
  <DD>비-숫자 문자와 일치한다; 다음 부류와 동일 <CODE>[^0-9]</CODE>. 
  <P></P>
  <DT><CODE>\s</CODE> 
  <DD>공백 문자와 일치한다; 다음 부류와 동일 <TT class=regexp>[ \t\n\r\f\v]</TT>. 
  <P></P>
  <DT><CODE>\S</CODE> 
  <DD>비-공백 문자와 일치한다; 다음 부류와 동일 <CODE>[^ \t\n\r\f\v]</CODE>. 
  <P></P>
  <DT><CODE>\w</CODE> 
  <DD>영문자숫자와 일치한다; 다음 부류와 동일 <TT class=regexp>[a-zA-Z0-9_]</TT>. 
  <P></P>
  <DT><CODE>\W</CODE> 
  <DD>비-영문자숫자와 일치한다; 다음 부류와 동일 <CODE>[^a-zA-Z0-9_]</CODE>. </DD></DL>
<P>이런 연속열은 문자 부류안에 포함될 수 있다. 예를 들어, <TT class=regexp>[\s,.]</TT>는 어떤 공백 문자에도 
일치하고, 또는 "<TT class=character>,</TT>"나 "<TT class=character>.</TT>"에도 일치하는 문자 
부류이다. 
<P>이 섹션에서 마지막으로 다룰 메타문자는 <TT class=regexp>.</TT>이다. 새줄문자 빼고는 어떤 문자와도 일치한다. 그리고 
대안 모드(<CODE>re.DOTALL</CODE>)가 있어서 새줄문자조차도 일치시킬 수 있다. "<TT 
class=character>.</TT>"는 ``어떤 문자''라도 일치시키고 싶을 때 자주 사용된다. 
<P>
<H2><A name=SECTION000320000000000000000>2.2 반복적인 작업</A> </H2>
<P>다양한 문자 집합에 일치시키는 능력은 정규 표현식이 할 수 있는 첫 번째 능력으로 이는 문자열에 메쏘드에서는 아직 가능하지 않은 능력이다. 
그렇지만, 그 정도가 regexes의 능력에 추가된 전부라면, 별로 크게 진보된 것이 아닐 것이다. 또다른 능력은 RE의 일부를 몇 번이라도 
반복하도록 지정할 수 있다는 것이다. 
<P>일을 반복하는데 사용되는 첫 번째 매개변수는 <TT class=regexp>*</TT>이다. <TT class=regexp>*</TT>는 
기호 문자"<TT class=samp>*</TT>"에 일치되지 않는다; 대신에, 이전의 문자가 정확하게 한번 말고 0회 이상 일치될 수 있도록 
지정할 수 있다. 
<P>예를 들어, <TT class=regexp>ca*t</TT>는 "<TT class=samp>ct</TT>" (0개의 "<TT 
class=samp>a</TT>" 문자), "<TT class=samp>cat</TT>" (1개의 "<TT class=samp>a</TT>" 
문자), "<TT class=samp>caaat</TT>" (3개의 "<TT class=samp>a</TT>" 문자), 등등에 일치한다. RE 
엔진은 C의 <CODE>int</CODE> 유형에서 기원하는 다양한 내부 제한이 있다. 이 제한 때문에 20억개가 넘는 "<TT 
class=samp>a</TT>" 문자에는 일치하지 않는다; 그 정도로 큰 문자열을 구성하려면 메모리가 충분하지 않을 것이므로, 그 한계에 
봉착해서는 안된다. 
<P><TT class=regexp>*</TT>와 같은 반복은 <I class=dfn>탐욕적(greedy)</I>이라고 한다; RE를 반복할 
때, 일치 엔진은 가능하면 많이 일치시키려고 시도할 것이다. 패턴의 나중 부분이 일치하지 않으면, 일치 엔진은 다시 돌아와 몇 번의 반복을 다시 
시도한다. 
<P>단계별 예제로 이 점을 보다 명확하게 밝혀 보겠다. <TT class=regexp>a[bcd]*b</TT>라는 표현식을 생각해 보자. 이는 
기호 "<TT class=character>a</TT>"와, 부류 <CODE>[bcd]</CODE>에서의 0회 이상의 기호와 일치하고, 그리고 
마지막으로 "<TT class=character>b</TT>"로 끝난다. 이제 이 RE를 문자열 "<TT 
class=samp>abcbd</TT>"에 일치시켜 본다고 생각해 보자. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>단계</B>&nbsp;</TH>
    <TH align=left><B>일치됨</B>&nbsp;</TH>
    <TH align=left><B>해설</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle>1</TD>
    <TD align=left><CODE>a</CODE></TD>
    <TD align=left>RE에서 <TT class=regexp>a</TT>가 일치한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>2</TD>
    <TD align=left><CODE>abcbd</CODE></TD>
    <TD align=left>엔진은 <TT class=regexp>[bcd]*</TT>에 일치하고, 최대한 멀리 가서, 문자열의 끝에 
      이른다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>3</TD>
    <TD align=left><I>Failure</I></TD>
    <TD align=left>엔진은 <TT class=regexp>b</TT>에 일치하려고 시도하지만, 현재 위치가 문자열의 끝이므로, 
      실패한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>4</TD>
    <TD align=left><CODE>abcb</CODE></TD>
    <TD align=left>다시 돌아온다, <TT class=regexp>[bcd]*</TT>가 하나 이하의 문자에 일치한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>5</TD>
    <TD align=left><I>Failure</I></TD>
    <TD align=left>다시 <TT class=regexp>b</TT>를 시도하지만, 현재 위치가 마지막 문자이다. 즉 "<TT 
      class=character>d</TT>"이다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>6</TD>
    <TD align=left><CODE>abc</CODE></TD>
    <TD align=left>다시 돌아온다, 그래서 <TT class=regexp>[bcd]*</TT>는 오직 "<TT 
      class=samp>bc</TT>"에만 일치한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle>6</TD>
    <TD align=left><CODE>abcb</CODE></TD>
    <TD align=left>다시 <TT class=regexp>b</TT>를 시도한다. 그러나 이 번에는 현재 위치의 문자가 "<TT 
      class=character>b</TT>"이고, 그래서 성공한다.</TD></TR></TBODY></TABLE>
<P>이제 RE의 마지막에 다다랐다. 그리고 "<TT class=samp>abcb</TT>"에 일치했다. 이는 어떻게 일치 엔진이 먼저 최대한 
멀리 가는지 보여준다. 만약 아무 일치도 발견하지 못하면 순차적으로 다시 돌아와 RE의 남은 부분을 계속해서 반복적으로 시도한다. <TT 
class=regexp>[bcd]*</TT>에 대하여 어떤 일치도 발견하지 못할 때까지 돌아 올 것이다. 그리고 잇달아 실패하면, 일치 엔진은 
그 문자열이 RE에 전혀 일치하지 않는다고 결론을 내릴 것이다. 
<P>또다른 반복 메타문자는 <TT class=regexp>+</TT>인데, 이는 1회 이상 일치한다. <TT 
class=regexp>*</TT>와 <TT class=regexp>+</TT>의 차이에 주의를 기울이자; <TT 
class=regexp>*</TT>는 <I>0회</I> 이상 일치하므로, 그래서 반복되는 것이 전혀 존재하지 않을 수도 있지만, 반면에 <TT 
class=regexp>+</TT>는 적어도 <I>한 번</I>의 출현을 요구한다. 비슷한 예를 들어 보면, <TT 
class=regexp>ca+t</TT>는 "<TT class=samp>cat</TT>" (1 "<TT class=samp>a</TT>"), 
"<TT class=samp>caaat</TT>" (3 "<TT class=samp>a</TT>"'s)에 일치하지만, "<TT 
class=samp>ct</TT>"에는 일치하지 않는다. 
<P>반복 수식자가 두 가지 더 있다. 물음표 문자 <TT class=regexp>?</TT>는 0회 또는 1회 일치한다; 즉 무언가가 선택적인 
것으로 표식설정되어 있는 것이라고 간주해도 좋다. 예를 들어, <TT class=regexp>home-?brew</TT>는 "<TT 
class=samp>homebrew</TT>" 또는 "<TT class=samp>home-brew</TT>"에 일치한다. 
<P>가장 복잡한 반복 수식자는 <TT class=regexp>{<VAR><FONT 
face=Times>m</FONT></VAR>,<VAR><FONT face=Times>n</FONT></VAR>}</TT>인데, 여기에서 
<VAR><FONT face=Times>m</FONT></VAR>과 <VAR><FONT face=Times>n</FONT></VAR>은 십진 
정수이다. 이 수식자는 최소 <VAR><FONT face=Times>m</FONT></VAR>회의 반복과, 최대 <VAR><FONT 
face=Times>n</FONT></VAR>회가 반복됨을 의미한다. 예를 들어, <TT class=regexp>a/{1,3}b</TT>는 
"<TT class=samp>a/b</TT>", "<TT class=samp>a//b</TT>", 그리고 "<TT 
class=samp>a///b</TT>"에 일치된다. "<TT class=samp>ab</TT>"에는 일치하지 않는데, 이는 사선이 없기 
때문이며, 또는 "<TT class=samp>a////b</TT>"에도 일치하지 않는데, 이는 사선이 네개이기 때문이다. 
<P><VAR><FONT face=Times>m</FONT></VAR> 또는 <VAR><FONT face=Times>n</FONT></VAR>을 
생략해도 좋다; 이 경우에, 생략된 값에 대하여 합리적인 값이 추정된다. <VAR><FONT face=Times>m</FONT></VAR>을 
생략하면 0으로 번역되는데, 반면에 <VAR><FONT face=Times>n</FONT></VAR>을 생략하면 최대 무한 값이 된다 -- 
실제로, 앞에서 20억이 한계라고 언급했지만, 그 정도면 무한이라고 해도 좋을 것 같다. 
<P>간결하게 처리하기를 좋아하는 독자라면 나머지 다른 수식자가 모두 다음 표기법으로 표현될 수 있다는 것을 눈치챘을 것이다. <TT 
class=regexp>{0,}</TT>는 <TT class=regexp>*</TT>이고, <TT class=regexp>{1,}</TT>는 
<TT class=regexp>+</TT>와 동등하며, 그리고 <TT class=regexp>{0,1}</TT>은 <TT 
class=regexp>?</TT>와 똑같다. 더 짧고 읽기 편하기 때문에 가능하면 <TT class=regexp>*</TT>, <TT 
class=regexp>+</TT>, 또는 <TT class=regexp>?</TT>를 사용하는 편이 좋다. 
<P>
<H1><A name=SECTION000400000000000000000>3 정규 표현식 사용하기</A> </H1>
<P>간단한 몇가지 정규 표현식을 둘러 보았다. 그렇하면 어떻게 실제로 정규 표현식을 파이썬에서 사용하는가? <TT 
class=module>re</TT> 모듈이 정규 표현식에 대한 인터페이스를 제공하여 주므로, RE를 객체로 컴파일해서 그들에 대해 일치를 
수행할 수 있다. 
<P>
<H2><A name=SECTION000410000000000000000>3.1 정규 표현식 컴파일하기</A> </H2>
<P>정규 표현식은 <TT class=class>RegexObject</TT> 실체로 컴파일된다. 이는 다양한 연산을 위한 메쏘드를 가지고 
있어서 패턴 일치를 찾거나 문자열 대치를 수행한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('ab*')
&gt;&gt;&gt; print p
&lt;re.RegexObject instance at 80b4150&gt;
</PRE></DIV>
<P><TT class=function>re.compile()</TT>은 또한 선택적인 표식(<VAR><FONT 
face=Times>flags</FONT></VAR>) 인수를 받는다. 이 인수를 사용하면 다양한 특수 특징들과 구문을 사용할 수 있다. 나중에 
사용가능한 설정값들을 검토해 보겠지만, 현재로서는 한가지 예제만으로도 충분할 것이다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)
</PRE></DIV>
<P>RE는 <TT class=function>re.compile()</TT>에 문자열로 건네진다. RE는 정규 표현식이 코어 파이썬 언어의 
일부가 아니기 때문에 문자열로 처리된다. 그리고 정규 표현식을 표현하는데 어떤 특별한 구문도 만들어지지 않는다. (RE가 전혀 필요하지 않은 
어플리케이션도 있어서, 정규 표현식을 포함했다고 자랑할 필요가 없다.) 대신, <TT class=module>re</TT> 모듈은 그냥 파이썬에 
포함된 C 확장 모듈이다. 마치 <TT class=module>socket</TT> 모듈이나 <TT class=module>zlib</TT> 
모듈처럼 말이다. 
<P>문자열로 RE를 표현하면 파이썬 언어는 더 간단하지만, 단점이 하나 있는데 다음 섹션의 주제로 삼겠다. 
<P>
<H2><A name=SECTION000420000000000000000>3.2 고민거리 역사선</A> </H2>
<P>이전에 언급한 바와 같이, 정규 표현식은 역사선 문자 ("<TT class=character>\</TT>")를 사용하여 그의 특별한 의미를 
요청하지 않고 특별한 형태를 나타내거나 특별한 문자를 사용하도록 허용한다. 이는 파이썬이 같은 문자를 같은 목적으로 문자열 기호문자에 사용하는 
것과 충돌한다. 
<P>RE를 문자열 "<TT class=samp>\section</TT>"에 일치시켜 보고 싶다고 하자, 이는 <SPAN 
class=logo,LaTeX>L<SUP><SMALL><FONT size=2>A</FONT></SMALL></SUP>T<SMALL><FONT 
size=2>E</FONT></SMALL>X</SPAN> 파일에서 봄직하다. 프로그램 코드에 무엇을 쓸지 가늠하려면, 먼저 일치시키기를 원하는 
문자열로 시작하자. 다음으로, 역사선을 앞에 두어서 역사선과 기타 메타문자들을 피신시키고 "<TT 
class=samp>\\section</TT>" 문자열을 만들어야 한다. <TT class=function>re.compile()</TT>으로 
건네야 하는 결과 문자열은 반드시 <CODE>\\section</CODE>이어야 한다. 그렇지만, 이를 파이썬 문자열 기호문자로 표현하려면, 
역사선 두 개 모두를 <I>또다시</I> 피신시켜야 한다. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>문자</B>&nbsp;</TH>
    <TH align=left><B>단계</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>\section</CODE></TD>
    <TD align=left>일치시킬 텍스트 문자열</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>\\section</CODE></TD>
    <TD align=left><TT class=function>re.compile</TT>을 위해 피신시킨 역사선</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\\\section"</CODE></TD>
    <TD align=left>문자열 기호문자를 위해 피신시킨 역사선</TD></TR></TBODY></TABLE>
<P>간단히 말해, 기호문자 역사선을 일치시키려면, RE 문자열로 <CODE>'\\\\'</CODE>라고 써야 하는데, 정규 표현식은 "<TT 
class=samp>\\</TT>"이어야 하고, 각 역사선은 정규 파이썬 문자열 기호문자 안에서 "<TT class=samp>\\</TT>"라고 
표현되어야 하기 때문이다. RE에서 역사선을 반복적으로 사용해야 한다면, 이는 수 많은 역사선의 반복으로 이어져야 하고 결과 문자열을 이해하기 
어렵게 된다. 
<P>해결책은 파이썬의 날 문자열 표기법을 정규 표현식에 사용하는 것이다; 역사선은 "<TT class=character>r</TT>"이 
접두사로 된 문자열 기호문자 안에서는 어떤 특별한 방법으로 다루어지지 않는다, 그래서 <CODE>r"\n"</CODE>은 두개의 문자 문자열로서 
"<TT class=character>\</TT>"와 "<TT class=character>n</TT>"를 담고 있는데, 반면에 
<CODE>"\n"</CODE>은 한개짜리 문자열로서 새줄문자를 담고 있다. 아주 자주 정규 표현식은 파이썬 코드에서 이런 날 문자열 표기법으로 
표현된다. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>정규 표현식</B>&nbsp;</TH>
    <TH align=middle><B>날 문자열</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"ab*"</CODE></TD>
    <TD align=middle><CODE>r"ab*"</CODE></TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\\\section"</CODE></TD>
    <TD align=middle><CODE>r"\\section"</CODE></TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\w+\\s+\\1"</CODE></TD>
    <TD align=middle><CODE>r"\w+\s+\1"</CODE></TD></TR></TBODY></TABLE>
<P>
<H2><A name=SECTION000430000000000000000>3.3 일치시켜 보기</A> </H2>
<P>컴파일된 정규 표현식을 나타내는 객체를 확보했다고 하면, 그것으로 무엇을 할 것인가? <TT 
class=class>RegexObject</TT> 실체는 여러 메쏘드와 속성을 가지고 있다. 가장 중요한 것들만 여기에서 다루어 보겠다; 
완벽한 목록은 <A class=ulink 
href="http://www.python.org/doc/lib/module-re.html"><U><FONT color=#0000bb>라이브러리 
참조서</FONT></U></A>를 참고하자. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>메쏘드/속성</B>&nbsp;</TH>
    <TH align=left><B>목적</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>match()</CODE></TD>
    <TD align=left>문자열의 처음에서 RE가 일치하는지 결정한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>search()</CODE></TD>
    <TD align=left>문자열을 ?어서, RE가 일치하는 위치를 찾는다.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>findall()</CODE></TD>
    <TD align=left>RE가 일치하는 곳의 모든 하부문자열을 찾아서, 그 문자열들을 리스트로 반환한다.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>finditer()</CODE></TD>
    <TD align=left>RE가 일치하는 곳의 모든 하부문자열을 찾아서, 그 문자열들을 반복자로 
반환한다.</TD></TR></TBODY></TABLE>
<P><TT class=method>match()</TT>와 <TT class=method>search()</TT>는 아무 일치도 발견하지 
못하면 <CODE>None</CODE>을 반환한다. 성공적으로 발견하면 <CODE>MatchObject</CODE> 실체가 반환되는데, 여기에는 
그 일치에 관한 정보가 담기어 있다: 어디에서 시작하고 끝나는지, 일치된 하부문자열, 등등. 
<P><TT class=module>re</TT> 모듈을 가지고 상호대화적으로 실험해 보면 이에 대하여 알 수 있다. Tkinter를 사용할 수 
있으면, 파이썬 배포본에 포함된 데모 프로그램인 <SPAN class=file><FONT 
face=Arial>Tools/scripts/redemo.py</FONT></SPAN>를 보고 싶을 것이다. 이 데모 프로그램에서 RE와 
문자열을 입력하면, RE가 일치하는지 실패하는지 화면에 보여준다. <SPAN class=file><FONT 
face=Arial>redemo.py</FONT></SPAN>는 복잡한 RE를 디버그하고 싶을 때 아주 쓸모가 있다. 필 슈바르쯔(Phil 
Schwartz)의 <A class=ulink href="http://kodos.sourceforge.net/"><U><FONT 
color=#0000bb>Kodos</FONT></U></A>도 또한 상호대화적인 도구로서 RE 패턴을 테스트하고 개발하는데 사용된다. 이 
HOWTO는 표준 파이썬을 예제로 사용할 것이다. 
<P>먼저, 파이썬을 실행하고, <TT class=module>re</TT> 모듈을 수입한 다음, RE를 컴파일 한다: 
<P>
<DIV class=verbatim><PRE>Python 2.2.2 (#1, Feb 10 2003, 12:57:01)
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('[a-z]+')
&gt;&gt;&gt; p
&lt;_sre.SRE_Pattern object at 80c3c28&gt;
</PRE></DIV>
<P>이제, 다양한 문자열을 RE <TT class=regexp>[a-z]+</TT>에 일치시켜 볼 수 있다. 빈 문자열은 절대로 일치되지 
않는데, 왜냐하면 <TT class=regexp>+</TT>는 '1회 이상의 반복'을 의미하기 때문이다. <TT 
class=method>match()</TT>는 이 경우에 <CODE>None</CODE>을 반환할 것이다. 그래서 파이썬에는 아무것도 인쇄되지 
않는다. 이 점을 명확히 하기 위하여 명시적으로 <TT class=method>match()</TT>의 결과를 인쇄해 볼 수 있다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p.match("")
&gt;&gt;&gt; print p.match("")
None
</PRE></DIV>
<P>이제, 일치 될 만한 문자열, 예를 들어 "<TT class=samp>tempo</TT>"와 같은 문자열에 시도해 보자. 이 경우에 <TT 
class=method>match()</TT>는 <TT class=class>MatchObject</TT>를 반환할 것이고, 그래서 그 결과를 
나중에 사용하기 위해 저장해 두어야 한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m = p.match( 'tempo')
&gt;&gt;&gt; print m
&lt;_sre.SRE_Match object at 80c4f68&gt;
</PRE></DIV>
<P>이제 일치된 문자열에 관하여 정보를 <TT class=class>MatchObject</TT>에 질의해 볼 수 있다. <TT 
class=class>MatchObject</TT> 실체는 또한 여러 메쏘드와 속성이 있다; 가장 중요한 것들은 다음과 같다: 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>메쏘드/속성</B>&nbsp;</TH>
    <TH align=left><B>목적</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>group()</CODE></TD>
    <TD align=left>RE에 일치된 문자열을 반환한다</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>start()</CODE></TD>
    <TD align=left>일치된 문자열의 시작 위치를 반환한다</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>end()</CODE></TD>
    <TD align=left>일치된 문자열의 끝 위치를 반환한다</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>span()</CODE></TD>
    <TD align=left>일치 위치를 (start, end)의 터플로 반환한다</TD></TR></TBODY></TABLE>
<P>이런 메쏘드들을 시험해 보면 곧 그 의미를 이해하게 된다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m.group()
'tempo'
&gt;&gt;&gt; m.start(), m.end()
(0, 5)
&gt;&gt;&gt; m.span()
(0, 5)
</PRE></DIV>
<P><TT class=method>group()</TT>은 RE에 일치된 하부문자열을 반환한다. <TT 
class=method>start()</TT>와 <TT class=method>end()</TT>는 각각 일치된 문자열의 시작 지표와 끝 위치를 
반환한다. <TT class=method>span()</TT>은 시작 위치와 끝 지표를 하나의 터플로 반환한다. <TT 
class=method>match</TT> 메쏘드는 RE가 문자열의 처음에서 일치하는지를 점검할 뿐이기 때문에, <TT 
class=method>start()</TT>는 언제나 0일 것이다. 그렇지만, <TT class=class>RegexObject</TT> 
실체의 <TT class=method>search</TT> 메쏘드는 문자열을 ?기 때문에, 일치 위치가 0이 아닐 수도 있다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print p.match('::: message')
None
&gt;&gt;&gt; m = p.search('::: message') ; print m
&lt;re.MatchObject instance at 80c9650&gt;
&gt;&gt;&gt; m.group()
'message'
&gt;&gt;&gt; m.span()
(4, 11)
</PRE></DIV>
<P>실제 프로그램에서, 가장 일반적인 스타일은 <TT class=class>MatchObject</TT>를 변수에 저장하고나서, 그것이 
<CODE>None</CODE>인지 점검하는 것이다. 이는 보통 다음과 같이 보인다: 
<P>
<DIV class=verbatim><PRE>p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
    print 'Match found: ', m.group()
else:
    print 'No match'
</PRE></DIV>
<P>두개의 <TT class=class>RegexObject</TT> 메쏘드가 한 패턴에 관하여 일치된 모든 것들을 반환한다. <TT 
class=method>findall()</TT>은 일치된 문자열들을 담은 리스트를 반환한다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']
</PRE></DIV>
<P><TT class=method>findall()</TT>은 전체 리스트를 만들어야만 결과로 반환할 수 있다. 파이썬 2.2에서는 <TT 
class=method>finditer()</TT> 메쏘드도 사용할 수 있는데, <TT class=class>MatchObject</TT> 
실체의 연속열을 반복자로 반환한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
&gt;&gt;&gt; iterator
&lt;callable-iterator object at 0x401833ac&gt;
&gt;&gt;&gt; for match in iterator:
...     print match.span()
...
(0, 2)
(22, 24)
(29, 31)
</PRE></DIV>
<P>
<H2><A name=SECTION000440000000000000000>3.4 모듈-수준의 함수</A> </H2>
<P><TT class=class>RegexObject</TT>을 만들고 그의 메쏘드를 호출할 필요가 없다; <TT 
class=module>re</TT> 모듈은 <TT class=function>match()</TT>, <TT 
class=function>search()</TT>, <TT class=function>sub()</TT>, 등등의 최상위 수준의 함수를 
제공하기도 한다. 이 함수들은 <TT class=class>RegexObject</TT> 메쏘드에 상응하는 인수들을 취해서, RE 문자열을 그의 
첫 인수로 더하고, 그리고 여전히 <CODE>None</CODE>이나 <TT class=class>MatchObject</TT> 실체를 
반환한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match(r'From\s+', 'Fromage amk')
None
&gt;&gt;&gt; re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')
&lt;re.MatchObject instance at 80c5978&gt;
</PRE></DIV>
<P>안을 들여다 보면, 이 함수들은 그냥 여러분을 위하여 <TT class=class>RegexObject</TT>를 만들고 거기에다 그에 
적절한 메쏘드를 요청한다. 또한 컴파일된 객체를 캐쉬에 저장하기도 하여서, 앞으로 같은 RE를 사용하여 호출되면 더 빠르게 수행된다. 
<P>이런 모듈-수준의 함수를 사용해야 할까, 아니면 <TT class=class>RegexObject</TT>를 확보해서 그의 메쏘드들을 직접 
호출해야 할까? 선택은 얼마나 자주 그 RE가 사용될 것인가에 달려 있고, 개인적인 코딩 스타일에 달려 있다. RE가 코드에서 한 곳에서만 
사용된다면, 모듈 함수가 아마도 더 편리할 것이다. 프로그램이 수 많은 정규 표현식을 담고 있거나, 같은 정규 표현식을 여러 곳에서 
재사용한다면, 모든 정의들을 한 곳에 모아서, 코드의 한 부분에서 모든 RE를 미리 컴파일 하는 편이 더 가치가 있을 것이다. 표준 
라이브러리에서 예제를 하나 취하자면, <SPAN class=file><FONT face=Arial>xmllib.py</FONT></SPAN>에서 
하나를 뽑아 보겠다: 
<P>
<DIV class=verbatim><PRE>ref = re.compile( ... )
entityref = re.compile( ... )
charref = re.compile( ... )
starttagopen = re.compile( ... )
</PRE></DIV>
<P>일반적으로 나는 단 한번만 사용할 때에도 컴파일된 객체로 작업하는 편을 선호한다. 그러나 나만한 순수주의자는 별로 없을 것이다. 
<P>
<H2><A name=SECTION000450000000000000000>3.5 컴파일 표식</A> </H2>
<P>컴파일 표식으로 정규 표현식이 어떻게 작동할 것인가에 관한 모습을 변경할 수 있다. 표식은 <TT class=module>re</TT> 
모듈에서 두 가지 이름을 사용할 수 있는데, 긴 이름으로 <TT class=constant>IGNORECASE</TT>, 그리고 짧은 이름으로 
하나짜리-기호 형태인 <TT class=constant>I</TT>가 있다. (펄의 패턴 변경자를 잘 안다면, 하나짜리-기호 형태는 같은 기호를 
사용한다; 예를 들어, 짧은 형태의 <TT class=constant>re.VERBOSE</TT>는 <TT 
class=constant>re.X</TT>이다.) 비트별로 논리합 연산을 하여 여러 표식이 지정될 수 있다; 예를 들어 <CODE>re.I | 
re.M</CODE>는 <TT class=constant>I</TT> 표식과 <TT class=constant>M</TT> 표식을 모두 
설정한다. 
<P>다음은 사용가능한 표식 테이블이다. 각각에 대하여 보다 자세하게 설명을 달았다. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>표식</B>&nbsp;</TH>
    <TH align=left><B>의미</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>DOTALL</TT>, <TT 
      class=constant>S</TT></TD>
    <TD align=left><TT class=regexp>.</TT>을 새줄문자도 포함하여 어떤 문자에도 일치하도록 만든다.</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>IGNORECASE</TT>, <TT 
      class=constant>I</TT></TD>
    <TD align=left>대소문자-구별없이 일치시킨다</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>LOCALE</TT>, <TT 
      class=constant>L</TT></TD>
    <TD align=left>로케일을-인식하여 일치시킨다</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>MULTILINE</TT>, <TT 
      class=constant>M</TT></TD>
    <TD align=left>여러-줄 일치, <TT class=regexp>^</TT>와 <TT class=regexp>$</TT>에 
      영향을 미친다</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>VERBOSE</TT>, <TT 
      class=constant>X</TT></TD>
    <TD align=left>RE에 설명을 붙일 수 있다. RE를 더 깨끗하고 이해하기 쉽게 조직할 수 
있다.</TD></TR></TBODY></TABLE>
<P>
<DL>
  <DT><B><A name=l2h-1><TT>I</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-6><TT>IGNORECASE</TT></A></B> 
  <DD>대소문자 비구별 일치를 수행한다; 문자 부류와 기호문자 문자열은 대소문자를 무시하고 기호에 일치한다. 예를 들어, <TT 
  class=regexp>[A-Z]</TT>는 소문자 기호에도 역시 일치할 것이고, <TT class=regexp>Spam</TT>은 "<TT 
  class=samp>Spam</TT>", "<TT class=samp>spam</TT>", 또는 "<TT 
  class=samp>spAM</TT>"에 일치할 것이다. 이런 소문자변환은 현재 로케일을 고려하지 않은 것이다; <TT 
  class=constant>LOCALE</TT> 표식을 설정해도 마찬가지다. </DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-2><TT>L</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-7><TT>LOCALE</TT></A></B> 
  <DD><TT class=regexp>\w</TT>, <TT class=regexp>\W</TT>, <TT 
  class=regexp>\b</TT>, 그리고 <TT class=regexp>\B</TT>를 현재 로케일에 의존하게 만든다. 
  <P>로케일은 언어의 차이를 고려하는 프로그램을 만드는데 도움을 줄 목적으로 만들어진 C 라이브러리의 특징이다. 예를 들어, 프랑스어 
  텍스트를 처리하고자 하면, <TT class=regexp>\w+</TT>를 단어에 일치시킬 수 있었으면 하고 바라지만, <TT 
  class=regexp>\w</TT>는 오직 문자 부류 <TT class=regexp>[A-Za-z]</TT>에만 일치할 뿐이다; 다시 말해 
  "<TT class=character>e</TT>" 또는 "<TT class=character>c</TT>"에 일치하지 않는다. 시스템이 
  제대로 환경설정되어 있고 프랑스어 로케일이 선택되었다면, 특정 C 함수들이 프로그램에게 "<TT class=character>e</TT>"이 
  기호로 간주되어야 한다고 말해 줄 것이다. 정규 표현식을 컴파일할 때 <TT class=constant>LOCALE</TT> 표식을 설정해 
  놓으면 그 결과로 나온 컴파일 객체가 <TT class=regexp>\w</TT>에 대하여 이런 C 함수들을 사용하게 된다; 이것이 더 
  느리지만, <TT class=regexp>\w+</TT>를 예상대로 프랑스어 단어에 일치시키도록 할 수 있다. </P></DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-3><TT>M</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-8><TT>MULTILINE</TT></A></B> 
  <DD>(<TT class=regexp>^</TT> 그리고 <TT class=regexp>$</TT>는 아직 설명하지 않았다; 이에 대해서는 
  섹션&nbsp;<A href="#more-metacharacters"><U><FONT 
  color=#0000bb>4.1</FONT></U></A>에서 소개할 생각이다.) 
  <P>보통 <TT class=regexp>^</TT>는 문자열의 처음에서만 일치한다. 그리고 <TT class=regexp>$</TT>는 
  문자열의 끝에서만 일치하고, (혹시 있다면) 문자열의 끝에 새줄문자 바로 앞에서 일치한다. 이 표식이 지정되면, <TT 
  class=regexp>^</TT>는 문자열의 처음과 그 문자열에서 다음에 새줄문자가 나오는 즉시 각 줄의 시작에서 일치한다. 비슷하게, 
  <TT class=regexp>$</TT> 메타문자는 각 줄의 끝과 문자열의 끝에서 일치한다 (각 새줄문자 바로 앞에서). 
  <P></P></DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-4><TT>S</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-9><TT>DOTALL</TT></A></B> 
  <DD>특수 문자 "<TT class=character>.</TT>"을 새줄문자를 포함하여 어떤 문자에도 일치하게 만든다; 이 표식이 
  없으면, "<TT class=character>.</TT>"는 새줄문자를 <I>제외하고</I> 어느 문자에도 일치한다. </DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-5><TT>X</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-10><TT>VERBOSE</TT></A></B> 
  <DD>이 표식을 사용하면 더 유연하게 정규 표현식의 모양을 만들수 있어서 정규 표현식을 더 읽기 쉽게 만들 수 있다. 이 표식이 지정되면, 
  RE 문자열 안의 공백은 무시된다. 단 공백이 문자 부류 안에 있거나 앞에 피신되지 않은 역사선이 있는 경우는 제외 된다; 이렇게 하면 
  RE를 보다 선명하게 들여쓰고 조직화할 수 있다. 또한 RE 안에 주석을 달 수 도 있는데 엔진이 무시한다; 주석은 "<TT 
  class=character>#</TT>"로 표시되며 이 문자는 문자 부류 안에 있어서도 안되고 앞에 피신되지 않는 역사선이 와도 안된다. 
  <P>예를 들어, 다음은 <TT class=constant>re.VERBOSE</TT>를 사용하는 RE이다; 읽기가 얼마나 더 쉬운지 보자. 

  <P>
  <DIV class=verbatim><PRE>charref = re.compile(r"""
 &amp;[#]		     # 수치 개체 참조의 시작
 (
   [0-9]+[^0-9]      # 십진 형태
   | 0[0-7]+[^0-7]   # 팔진 형태
   | x[0-9a-fA-F]+[^0-9a-fA-F] # 십육진 형태
 )
""", re.VERBOSE)
</PRE></DIV>
  <P>verbose가 설정되어 있지 않으면, RE는 다음처럼 보일 것이다: 
  <DIV class=verbatim><PRE>charref = re.compile("&amp;#([0-9]+[^0-9]"
                     "|0[0-7]+[^0-7]"
                     "|x[0-9a-fA-F]+[^0-9a-fA-F])")
</PRE></DIV>
  <P>위의 예제에서, 파이썬이 문자열 기호문자들을 자동으로 결합하여 RE를 더 작은 조작으로 부수었지만, <TT 
  class=constant>re.VERBOSE</TT>를 사용한 버전보다 여전히 더 이해하기 어렵다. 
  <P></P></DD></DL>
<P>
<H1><A name=SECTION000500000000000000000>4 패턴 파워에 대하여 더 자세히</A> </H1>
<P>지금까지는 정규 표현식의 일부를 다루어 보았을 뿐이다. 이 섹션에서는, 새로운 메타문자들 몇가지를 다루어 보고, 그룹을 사용하여 일치된 
텍스트의 일부를 열람하는 법을 다루어 보겠다. 
<P>
<H2><A name=SECTION000510000000000000000></A> <BR>4.1 메타문자들을 더 자세히</H2>
<P>아직 다루어 보지 않은 메타문자들이 몇가지 있다. 그들 대부분을 이 섹션에서 다루어 보겠다. 
<P>남아있는 메타문자중 다루어 볼 메타문자는 <I class=dfn>0-너비 선언</I>이다. <I class=dfn>0-너비 선언</I> 
문자들에서 엔진은 문자열에서 앞으로 나아가지 않는다; 대신에, 전혀 문자들을 소비하지 않으며, 그냥 성공하거나 실패할 뿐이다. 예를 들어, 
<TT class=regexp>\b</TT>는 현재 위치가 언어의 경계에 있다는 선언이다; 위치는 <TT class=regexp>\b</TT>에 
의해서 전혀 변하지 않는다. 이는 곧 0-너비 선언이 절대로 반복되지 않는다는 뜻인데, 주어진 위치에서 한 번 일치하면, 수 없이 많은 횟수를 
일치할 것이 뻔하기 때문이다. 
<P>
<DL compact>
  <DT><TT class=regexp>|</TT> 
  <DD>대안, 또는 ``or'' 연산자이다. A와 B가 정규 표현식이라면, <TT class=regexp>A|B</TT>는 "<TT 
  class=samp>A</TT>" 또는 "<TT class=samp>B</TT>"에 일치하는 어느 문자열과도 일치한다. <TT 
  class=regexp>|</TT>는 여러-문자 문자열을 교체할 때 합리적으로 작동해야 하기 때문에 우선순위가 아주 낮다. <TT 
  class=regexp>Crow|Servo</TT>는 "<TT class=samp>Crow</TT>"나 "<TT 
  class=samp>Servo</TT>"에 일치하지만, "<TT class=samp>Cro</TT>", "<TT 
  class=character>w</TT>" 또는 "<TT class=character>S</TT>", 그리고 "<TT 
  class=samp>ervo</TT>"에는 일치하지 않는다. 
  <P>기호문자 "<TT class=character>|</TT>"에 일치시키려면, <TT class=regexp>\|</TT>을 사용하거나, 
  또는 다음과 같이 <TT class=regexp>[|] </TT>문자 부류 안에 싸 넣자. 
  <P></P>
  <DT><TT class=regexp>^</TT> 
  <DD>줄의 처음과 일치한다. <TT class=constant>MULTILINE</TT> 표식이 설정되어 있지 않는 한, 이는 그 문자열의 
  처음에만 일치할 것이다. <TT class=constant>MULTILINE</TT> 모드에서, 이는 그 문자열 안에서 각 새줄문자 다음과 
  바로 일치한다. 
  <P>예를 들어, "<TT class=samp>From</TT>"이라는 단어를 한 줄의 처음에만 일치시키고 싶으면, 사용할 RE는 
  <CODE>^From</CODE>이다. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('^From', 'From Here to Eternity')
&lt;re.MatchObject instance at 80c1520&gt;
&gt;&gt;&gt; print re.search('^From', 'Reciting From Memory')
None
</PRE></DIV>
  <P></P>
  <DT><TT class=regexp>$</TT> 
  <DD>줄의 마지막에 일치한다, 이는 문자열의 끝으로 정의되거나, 또는 새줄문자 다음의 위치로 정의된다. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('}$', '{block}')
&lt;re.MatchObject instance at 80adfa8&gt;
&gt;&gt;&gt; print re.search('}$', '{block} ')
None
&gt;&gt;&gt; print re.search('}$', '{block}\n')
&lt;re.MatchObject instance at 80adfa8&gt;
</PRE></DIV>
  <P>기호문자 "<TT class=character>$</TT>"를 일치시키려면, <TT class=regexp>\$</TT>를 사용하거나 
  다음과 같이 <TT class=regexp>[$]</TT> 문자 부류 안에 싸 넣자. 
  <P></P>
  <DT><TT class=regexp>\A</TT> 
  <DD>문자열의 처음에만 일치한다. <TT class=constant>MULTILINE</TT> 모드가 아니라면, <TT 
  class=regexp>\A</TT>와 <TT class=regexp>^</TT>는 그 효과가 같다. 그렇지만 <TT 
  class=constant>MULTILINE</TT> 모드라면, 효과가 다르다; <TT class=regexp>\A</TT>는 여전히 
  문자열의 처음에 일치하지만, <TT class=regexp>^</TT>은 문자열 안에서 새줄문자 뒤면 어느 위치에나 일치해도 좋다. 
  <P></P>
  <DT><TT class=regexp>\Z</TT> 
  <DD>문자열의 끝에만 일치한다. 
  <P></P>
  <DT><TT class=regexp>\b</TT> 
  <DD>단어 경계이다. 이는 0-너비 선언으로서 단어의 처음이나 끝에만 일치한다. 단어는 영문자숫자 문자의 연속열로 정의된다, 그래서 단어의 
  끝은 공백이나 비-영문자숫자 문자로 나타낸다. 
  <P>다음 예제에서는 완전한 단어일 때만 "<TT class=samp>class</TT>"가 일치한다; 그 안에 또다른 단어가 포함되어 
  있으면 일치하지 않는다. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\bclass\b')
&gt;&gt;&gt; print p.search('no class at all')
&lt;re.MatchObject instance at 80c8f28&gt;
&gt;&gt;&gt; print p.search('the declassified algorithm')
None
&gt;&gt;&gt; print p.search('one subclass is')
None
</PRE></DIV>
  <P>이런 특수 연속열을 사용할 때 명심해야할 미묘한 문제가 두가지 있다. 첫째, 파이썬의 문자열 기호문자와 정규 표현식의 연속열 사이의 
  심각한 충돌이다. 파이썬 문자열 기호문자에서, "<TT class=samp>\b</TT>"는 역사선 문자이며, ASCII 값이 8이다. 날 
  문자열을 사용하지 않으면, 파이썬은 "<TT class=samp>\b</TT>"를 백스페이스로 변환하고, RE는 예상되로 일치하지 않는다. 
  다음 예제는 앞의 RE와 똑 같아 보이지만, RE 문자열의 앞에 "<TT class=character>r</TT>"이 빠져 있다. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('\bclass\b')
&gt;&gt;&gt; print p.search('no class at all')
None
&gt;&gt;&gt; print p.search('\b' + 'class' + '\b')  
&lt;re.MatchObject instance at 80c3ee0&gt;
</PRE></DIV>
  <P>둘째, 이런 선언이 사용되지 않는 문자 부류 안에서, <TT class=regexp>\b</TT>는 파이썬의 문자열 문자기호와의 
  호환성을 위해서 백스페이스 문자를 나타낸다. 
  <P></P>
  <DT><TT class=regexp>\B</TT> 
  <DD>또다른 0-너비 선언이다. 이는 <TT class=regexp>\b</TT>의 반대로서, 현재 위치가 단어 경계가 아닐 때만 
  일치한다. 
  <P></P></DD></DL>
<P>
<H2><A name=SECTION000520000000000000000>4.2 그룹짓기</A> </H2>
<P>단순히 RE가 일치했는지의 여부보다 더 많은 정보를 얻고 싶을 때가 많다. 정규 표현식은 RE를 여러 하부그룹으로 잘라서 서로 다른 해당 
구성요소들에 일치하도록 작성함으로써 문자열을 분할 하는데 자주 사용된다. 예를 들어, RFC-822 머리부 줄은 머리부 이름과 값으로 나뉘고, 
"<TT class=character>:</TT>"로 갈린다. 이는 전체 머리부 줄에 일치하는 정규 표현식을 작성하면 처리될 수 있다. 정규 
표현식에서 한 그룹은 머리부 이름에 일치하고 다른 그룹은 머리부의 값에 일치하도록 하면 된다. 
<P>그룹은 "<TT class=character>(</TT>", "<TT class=character>)</TT>" 메타문자로 표식된다. 
"<TT class=character>(</TT>" 그리고 "<TT class=character>)</TT>"는 수학 표현식에서의 의미와 거의 
같다; 표현식들을 사이에 함께 그룹짓는다. 예를 들어, <TT class=regexp>*</TT>, <TT class=regexp>+</TT>, 
<TT class=regexp>?</TT>, 또는 <TT class=regexp>{<VAR><FONT 
face=Times>m</FONT></VAR>,<VAR><FONT face=Times>n</FONT></VAR>}</TT>와 같은 반복 수식자로 
그룹의 내용을 반복할 수 있다. <TT class=regexp>(ab)*</TT>는 "<TT class=samp>ab</TT>"의 하나이상의 
반복과 일치한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(ab)*')
&gt;&gt;&gt; print p.match('ababababab').span()
(0, 10)
</PRE></DIV>
<P>"<TT class=character>(</TT>", "<TT class=character>)</TT>"로 나타낸 그룹은 일치한 텍스트의 
시작 지표와 끝 지표를 얻을 수 있다; 이 지표를 열람하려면 인수를 <TT class=method>group()</TT>, <TT 
class=method>start()</TT>, <TT class=method>end()</TT>, 그리고 <TT 
class=method>span()</TT>에 건네면 된다. 그룹은 0에서부터 번호가 매겨진다. 그룹 0번은 언제나 존재한다; 즉 온전한 전체 
RE이며, 그래서 <TT class=class>MatchObject</TT> 메쏘드는 모두 그룹 0을 기본 인수로 가진다. 나중에 일치한 
텍스트의 범위를 나포하지 않는 그룹을 표현하는 법을 살펴 보겠다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(a)b')
&gt;&gt;&gt; m = p.match('ab')
&gt;&gt;&gt; m.group()
'ab'
&gt;&gt;&gt; m.group(0)
'ab'
</PRE></DIV>
<P>하부그룹은 왼쪽에서 오른쪽으로, 1부터 위로 번호가 매겨진다. 그룹은 내포될 수 있다; 그 번호를 결정하려면, 그냥 열린 괄호의 문자를 
왼쪽에서 오른쪽으로 세어 보면 된다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(a(b)c)d')
&gt;&gt;&gt; m = p.match('abcd')
&gt;&gt;&gt; m.group(0)
'abcd'
&gt;&gt;&gt; m.group(1)
'abc'
&gt;&gt;&gt; m.group(2)
'b'
</PRE></DIV>
<P><TT class=method>group()</TT>은 여러 그룹 번호를 한 번에 건넬 수 있는데, 이런 경우 그런 그룹에 대하여 상응하는 
값들을 담은 터플을 반환한다. 
<P>
<DIV class=verbatim><PRE>  
&gt;&gt;&gt; m.group(2,1,2)
('b', 'abc', 'b')
</PRE></DIV>
<P><TT class=method>groups()</TT> 메쏘드는 1에서 시작하여 얼마나 많이 있든지 모든 하부그룹의 문자열을 담은 터플을 
반환한다. 
<P>
<DIV class=verbatim><PRE>  
&gt;&gt;&gt; m.groups()
('abc', 'b')
</PRE></DIV>
<P>패턴에 역참조를 사용하면 이전 나포 그룹의 내용이 문자열의 현재 위치에서도 역시 발견되어야 한다고 지정할 수 있다. 예를 들어, <TT 
class=regexp>\1</TT>은 그룹 1의 정확한 내용이 현재 위치에서 발견되면 성공하고, 그렇지 않으면 실패한다. 꼭 기억해야 할 것은 
파이썬의 문자열 기호문자들도 역시 역사선 다음에 숫자를 사용하여 임의의 문자들을 문자열에 포함하기 때문에, RE에 역참조를 구현할 때는 날 
문자열을 사용하라는 것이다. 
<P>예를 들어, 다음의 RE는 문자열에서 중복되는 단어를 탐지한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(\b\w+)\s+\1')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</PRE></DIV>
<P>이와 같은 역참조는 문자열을 그냥 탐색할 때는 별로 쓸모가 없다 -- 이런 식으로 데이터가 반복되는 텍스트 형태는 거의 없다 -- 하지만 
문자열 대체를 수행할 때는 <I>아주</I> 쓸모가 있다는 것을 알게 될 것이다. 
<P>
<H2><A name=SECTION000530000000000000000>4.3 비-나포 그룹과 이름붙은 그룹</A> </H2>
<P>정교한 RE라면 많은 그룹을 가질 수 있고, 관심을 둔 하부문자열을 나포하고 또 RE 그 자체를 그룹짓고 구성할 수 있다. 복잡한 
RE에서는, 그룹 번호를 추적 유지하기가 힘들어진다. 이 문제를 도와줄 특징이 두가지 있다. 두 가지 특징 모두 정규 표현식 확장에 대하여 
공통인 구문을 사용하기 때문에, 먼저 이것을 살펴 보겠다. 
<P>펄 5에는 표준 정규 표현식에 여러 특징들이 추가되었다. 파이썬의 <TT class=module>re</TT> 모듈은 그렇게 추가된 것들을 
대부분 지원한다. 펄의 정규 표현식을 표준 RE와 아주 다르게 만들지 않고서, 새로운 한개짜리 메타문자나 또는 "<TT 
class=samp>\</TT>"로 시작하는 새로운 특수 연속열을 골라서 새로운 특징을 나타내기는 어려웠을 것이다. 예를 들어 "<TT 
class=samp>&amp;</TT>"를 새로운 메타문자로 골랐다면, 구형 표현식은 "<TT class=samp>&amp;</TT>"가 정규 
문자라고 간주할 것이고 이것을 피신시키기 위하여 <TT class=regexp>\&amp;</TT> 또는 <TT 
class=regexp>[&amp;]</TT>를 작성하려고는 하지 않을 것이다. 
<P>펄 개발자들이 고른 해결책은 <TT class=regexp>(?...)</TT>를 확장 구문으로 사용한 것이었다. 괄호 바로 다음에 나오는 
"<TT class=samp>?</TT>"는 반복할 것이 없을 것이므로, 이렇게 해서 호환성 문제가 야기되지 않았다. "<TT 
class=samp>?</TT>" 바로 다음의 문자들은 어떤 확장자가 사용되고 있는지를 나타내고, 그래서 (긍정적인 내다보기 선언인) <TT 
class=regexp>(?=foo)</TT>과 (하부 표현식 <TT class=regexp>foo</TT>를 담고 있는 비-나포 그룹인) 
<TT class=regexp>(?:foo)</TT>는 다르다. 
<P>파이썬은 펄의 확장 구문에 또 확장 구문을 추가한다. 물음 표 다음에 첫 문자가 "<TT class=samp>P</TT>"라면, 파이썬에 
종속적인 확장이다. 현재로는 그런 확장이 두 가지가 있다: <TT class=regexp>(?P&lt;<VAR><FONT 
face=Times>name</FONT></VAR>&gt;...)</TT>는 이름붙인 그룹을 정의한다. 그리고 <TT 
class=regexp>(?P=<VAR><FONT face=Times>name</FONT></VAR>)</TT>는 이름붙은 그룹에 대한 
역참조이다(backreference). 앞으로 Perl 5의 미래 버전에서 다른 구문을 사용하여 비슷한 특징이 추가된다면, <TT 
class=module>re</TT> 모듈은 그 새로운 구문을 지원하기 위해 변경될 것이다. 한편으로 호환성을 위해 그 파이썬 종속적인 구문은 
유지할 것이다. 
<P>이제 일반적인 확장 구문을 살펴 보았으므로, 복잡한 RE로 그룹을 처리하는 작업을 간단히 해주는 특징으로 되돌아가 보자. 그룹은 왼쪽에서 
오른쪽으로 번호가 매겨지고 복잡한 표현식은 많은 그룹을 사용할 수 있기 때문에, 올바른 번호매기기를 추적 유지하기가 점점 힘들어진다. 그렇게 
복잡한 RE를 변경하는 작업은 짜증나는 일이다. 앞부분에다 새로운 그룹을 삽입하면, 그 다음에 따르는 모든 것들의 번호가 변경된다. 
<P>먼저, 그룹을 사용하여 정규 표현식의 부분을 모으고 싶지만, 그룹의 내용을 열람하는데는 관심이 없을 때가 자주 있다. 이 의도를 명확하게 
나타내고 싶으면 비-나포 그룹을 사용하면 된다: <TT class=regexp>(?:...)</TT>가 바로 그것인데, 괄호 안에 다른 어떤 
정규 표현식도 넣을 수 있다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m = re.match("([abc])+", "abc")
&gt;&gt;&gt; m.groups()
('c',)
&gt;&gt;&gt; m = re.match("(?:[abc])+", "abc")
&gt;&gt;&gt; m.groups()
()
</PRE></DIV>
<P>일치된 그룹들의 내용을 열람할 수 없다는 사실만 제외하면, 비-나포 그룹은 정확하게 나포 그룹과 똑 같이 행위한다; 그 안에 무엇이든지 
넣을 수 있고, "<TT class=samp>*</TT>"와 같은 반복 문자로 반복할 수 있으며, 그리고 (나포 그룹이든 비-나포 그룹이든 
상관없이) 다른 그룹 안에 내포시킬 수 있다. <TT class=regexp>(?:...)</TT>가 특히 유용할 때는 기존의 그룹을 변경할 때 
인데, 왜냐하면 다른 모든 그룹들이 어떻게 번호가 매겨져야 하는지 바꾸지 않고서도 새로운 그룹을 추가할 수 있기 때문이다. 나포 그룹과 비 나포 
그룹 사이에 탐색에 있어서의 수행성능의 차이는 전혀 없다는 사실을 꼭 언급해야겠다; 한 형태가 다른 형태보다 더 빠르거나 하지는 않는다. 
<P>둘째로 더 중요한 특징은 이름붙은 그룹이다; 번호로 그룹을 참조하는 대신에, 그룹에 이름을 붙여 참조할 수 있다. 
<P>이름붙은 그룹을 위한 구문은 파이썬-종속적인 확장의 하나이다: <TT class=regexp>(?P&lt;<VAR><FONT 
face=Times>name</FONT></VAR>&gt;...)</TT>이 바로 그것인데, <VAR><FONT 
face=Times>name</FONT></VAR>이 당연히 그 그룹의 이름이다. 이름을 그룹에 연관짓는다는 것만 제외하면, 이름붙은 그룹도 
역시 나포 그룹과 동일하게 행위한다. 나포 그룹을 다루는 <TT class=class>MatchObject</TT> 메쏘드들은 모두 번호로 
그룹을 참조하기 위한 정수나 또는 그룹 이름을 담은 문자열을 받는다. 이름붙은 그룹은 여전히 번호가 주어진다. 그래서 두 가지 방식으로 그룹에 
관한 정보를 열람할 수 있다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+\b)')
&gt;&gt;&gt; m = p.search( '(((( Lots of punctuation )))' )
&gt;&gt;&gt; m.group('word')
'Lots'
&gt;&gt;&gt; m.group(1)
'Lots'
</PRE></DIV>
<P>이름붙은 그룹은 번호를 기억하기 보다 쉽게 이름을 기억할 수 있기 때문에 간편하다. 다음은 <TT 
class=module>imaplib</TT> 모듈에서 가져온 예제 RE이다: 
<P>
<DIV class=verbatim><PRE>InternalDate = re.compile(r'INTERNALDATE "'
        r'(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-'
	r'(?P&lt;year&gt;[0-9][0-9][0-9][0-9])'
        r' (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])'
        r' (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])'
        r'"')
</PRE></DIV>
<P>그룹 9번을 기억해서 열람하는 것보다, 확실히 더 쉽게 <CODE>m.group('zonem')</CODE> 열람할 수 있다. 
<P><TT class=regexp>(...)\1</TT>과 같은 표현식에서 역참조를 위한 구문은 그룹의 번호를 참조하기 때문에, 당연히 번호 
대신에 그룹 이름을 사용하는 변종들이 있다. 이 또한 파이썬 확장이다: <TT class=regexp>(?P=<VAR><FONT 
face=Times>name</FONT></VAR>)</TT>은 <VAR><FONT face=Times>name</FONT></VAR>이라고 
부르는 그룹의 내용이 현재 위치에서 다시 발견되어야 함을 나타낸다. 중복된 단어를 찾는 정규 표현식인 <TT 
class=regexp>(\b\w+)\s+\1</TT>는 다음과 같이 <TT 
class=regexp>(?P&lt;word&gt;\b\w+)\s+(?P=word)</TT> 씌여질 수도 있다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+)\s+(?P=word)')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</PRE></DIV>
<P>
<H2><A name=SECTION000540000000000000000>4.4 내다보기 선언(Lookahead Assertions)</A> 
</H2>
<P>또다른 0-너비 확인은 내다보기 선언이다. 내다보기 선언은 긍정적인 형태와 부정적인 형태로 사용할 수 있으며 다음과 같다: 
<P>
<DL compact>
  <DT><TT class=regexp>(?=...)</TT> 
  <DD>긍정적인 내다보기 선언. 여기에서는 <CODE>...</CODE>로 나타낸 담겨진 정규 표현식이 현재 위치에서 성공적으로 일치하면 
  성공하고, 그렇지 않으면 실패한다. 그러나, 일단 담겨진 정규 표현식이 시도되더라도, 일치 엔진은 더 이상 진행되지 않는다; 나머지 패턴이 
  그 확인이 시작된 바로 그 곳에서 시도된다. 
  <P></P>
  <DT><TT class=regexp>(?!...)</TT> 
  <DD>부정적인 내다보기 선언. 이는 긍정적인 확인의 반대이다; 담겨진 문자열이 문자열의 현재 위치에서 일치하지 <I>않으면</I> 
  성공한다. </DD></DL>
<P>내다보기 선언이 쓸모가 있는 사례를 보여주는 예제를 보면 이것을 확실하게 이해하는데 도움이 될 것이다. 파일이름에 일치하고 그 이름을 
"<TT class=samp>.</TT>"을 가름자로 하여 기본 이름과 확장자로 가르는 간단한 패턴을 생각해 보자. 예를 들어 "<TT 
class=samp>news.rc</TT>"에서, "<TT class=samp>news</TT>"는 기본 이름이고, "<TT 
class=samp>rc</TT>"는 그 파일이름의 확장자이다. 
<P>이에 일치하는 패턴은 아주 간단하다: 
<P><TT class=regexp>.*[.].*$</TT> 
<P>주목할 것은 "<TT class=samp>.</TT>"이 메타문자이기 때문에 특별하게 취급되어야 한다는 것이다; 나는 그 문자를 문자 
부류에 넣었다. 또 이끌리는 <TT class=regexp>$</TT>에 주목하자; 이것을 추가한 이유는 문자열의 나머지 모두를 확장자에 확실히 
포함시켜야 하기 때문이다. 이 정규 표현식은 "<TT class=samp>foo.bar</TT>"와 "<TT 
class=samp>autoexec.bat</TT>" 또 "<TT class=samp>sendmail.cf</TT>" 그리고 "<TT 
class=samp>printers.conf</TT>"에 일치한다. 
<P>이제, 문제를 조금 더 복잡하게 해 보자; 확장자가 "<TT class=samp>bat</TT>"이 아닌 파일이름에 일치시키고 싶으면 
어떻게 할까? 약간 올바르지 못한 시도를 보면: 
<P><CODE>.*[.][^b].*$</CODE> 
<P>위에서 첫 시도는 확장자의 첫 문자가 "<TT class=samp>b</TT>"가 아니도록 요구함으로써 "<TT 
class=samp>bat</TT>"를 제외하려고 시도한다. 이는 잘못된 것이다. 그 이유는 패턴이 "<TT 
class=samp>foo.bar</TT>"에도 일치하지 않기 때문이다. 
<P><TT class=regexp>.*[.]([^b]..|.[^a].|..[^t])$</TT> 
<P>표현식은 다음 사례중의 하나와 일치하도록 요구함으로써 처음의 해결책을 덧대려고 시도하면 더 지저분해 진다: 확장자의 첫 문자는 "<TT 
class=samp>b</TT>"가 아니다; 두 번째 문자는 "<TT class=samp>a</TT>"가 아니다; 또는 세 번째 문자는 "<TT 
class=samp>t</TT>"가 아니다. 이는 "<TT class=samp>foo.bar</TT>"를 받아들이고 "<TT 
class=samp>autoexec.bat</TT>"는 버린다. 하지만 세개짜리-기호 확장자를 요구하고 "<TT 
class=samp>sendmail.cf</TT>"과 같은 두 개짜리-기호 확장자를 가진 파일이름은 받아 들이지 않는다. 이를 고쳐 보기 위해서 
패턴을 복잡하게 만들어 보겠다. 
<P><TT class=regexp>.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</TT> 
<P>세 번째 시도에서,"<TT class=samp>sendmail.cf</TT>"와 같이 세 문자보다 더 짧은 확장자와 일치하도록 하기 위해 
두 번째와 세 번째 기호들을 모두 선택적으로 만들었다. 
<P>패턴은 이제 정말 복잡해져서, 읽고 이해하기가 어렵다. 더 나쁜 것은, 상황이 변해서 확장자에서 "<TT 
class=samp>bat</TT>"와 "<TT class=samp>exe</TT>"를 제외하고 싶어지면, 패턴이 훨씬 더 복잡해지고 
혼란스러워진다는 것이다. 
<P>부정적인 내다보기 선언이 이 모든 것을 단칼에 해결해 준다: 
<P><TT class=regexp>.*[.](?!bat$).*$</TT> 
<P>이 내다보기 선언의 의미는: 만약 확장자 <TT class=regexp>bat</TT>가 이 시점에서 일치하지 않으면, 패턴의 나머지를 
시도하라는 뜻이다; 만약 <TT class=regexp>bat$</TT>가 일치하면, 전체 패턴은 실패한다. 뒤 따르는 <TT 
class=regexp>$</TT>는 "<TT class=samp>sample.batch</TT>"와 같은 것이 허용된다는 것을 확인하는데 
필요하다. 확장자는 "<TT class=samp>bat</TT>"로 시작해야만 한다. 
<P>다른 파일이름 확장자를 제외하는 일은 이제 쉽다; 그냥 내다보기 선언의 안에다 대안으로 추가해 넣기만 하면 된다. 다음 패턴은 "<TT 
class=samp>bat</TT>"나 "<TT class=samp>exe</TT>"로 끝나는 파일이름 확장자를 제외시킨다: 
<P><TT class=regexp>.*[.](?!bat$|exe$).*$</TT> 
<P>
<H1><A name=SECTION000600000000000000000>5 문자열 변경하기</A> </H1>
<P>이 시점까지는, 정적인 문자열에 대하여 탐색을 수행했을 뿐이다. 정규 표현식은 또한 다양한 방법으로, 문자열을 변경하는데에도 사용된다. 
<TT class=class>RegexObject</TT> 메쏘드를 사용하면 된다: 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>메쏘드/속성</B>&nbsp;</TH>
    <TH align=left><B>목적</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>split()</CODE></TD>
    <TD align=left>RE가 일치할 때마다 문자열을 갈라서 리스트에 넣는다</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>sub()</CODE></TD>
    <TD align=left>RE가 일치하는 모든 하부문자열을 찾아서 다른 문자열로 바꾼다.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>subn()</CODE></TD>
    <TD align=left><TT class=method>sub()</TT>와 똑 같은 일을 하지만, 새로운 문자열과 대치 횟수를 
      반환한다</TD></TR></TBODY></TABLE>
<P>
<H2><A name=SECTION000610000000000000000>5.1 문자열 가르기</A> </H2>
<P><TT class=class>RegexObject</TT>의 <TT class=method>split()</TT> 메쏘드는 RE가 일치하는 
곳마다 문자열을 갈라서, 그 조각들을 담은 리스트를 반환한다. 문자열의 <TT class=method>split()</TT> 메쏘드와 
비슷하지만, 가를 수 있는 가름자에서 훨씬 더 많은 융통성을 제공한다; <TT class=method>split()</TT>은 오직 공백이나 
고정된 문자열로 가르기를 지원할 뿐이다. 예상하다시피, 모듈 수준의 <TT class=function>re.split()</TT> 함수도 역시 
있다. 
<P>
<DL>
  <DT>
  <TABLE cellSpacing=0 cellPadding=0>
    
    <TR vAlign=baseline>
      <TD><NOBR><B><A name=l2h-11><TT 
      class=method>split</TT></A></B>(</NOBR></TD>
      <TD><VAR><FONT face=Times>string </FONT></VAR><BIG><FONT 
        size=4>[</FONT></BIG><VAR><FONT face=Times>, maxsplit</FONT><CODE> = 
        0</CODE></VAR><BIG><FONT size=4>]</FONT></BIG>)</TD></TR></TABLE>
  <DD>정규 표현식의 일치를 기준으로 문자열(<VAR><FONT face=Times>string</FONT></VAR>)을 가른다. 나포 
  괄호가 RE에 사용되면, 그 내용물도 역시 결과 리스트의 일부분으로 반환된다. 만약 <VAR><FONT 
  face=Times>maxsplit</FONT></VAR>이 0이 아니면, 최대 <VAR><FONT 
  face=Times>maxsplit</FONT></VAR>만큼 가르기가 수행된다. </DD></DL>
<P><VAR><FONT face=Times>maxsplit</FONT></VAR>에 값을 건네면 가르기 횟수를 제한할 수 있다. 
<VAR><FONT face=Times>maxsplit</FONT></VAR>이 0이 아니면, 최대한 <VAR><FONT 
face=Times>maxsplit</FONT></VAR> 만큼의 가르기가 수행되고, 문자열의 나머지는 리스트의 마지막 요소로 반환된다. 다음 
예제에서, 가름자는 비-영문자숫자 문자들의 연속열이다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
</PRE></DIV>
<P>가름자 사이에 있는 텍스트가 무엇인지에 관심이 있을 뿐만 아니라 그 가름자가 무엇인지도 알 필요가 있을 경우가 자주 있다. 나포 괄호가 
RE에 사용되면, 그 값들도 또한 리스트의 일부분으로 반환된다. 다음 호출을 비교해 보자: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p2 = re.compile(r'(\W+)')
&gt;&gt;&gt; p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
&gt;&gt;&gt; p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
</PRE></DIV>
<P>모듈-수준의 함수 <TT class=function>re.split()</TT>에는 RE가 첫 인수로 사용되도록 추가되었지만, 다른 것은 
똑 같다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; re.split('[\W]+', 'Words, words, words.')
['Words', 'words', 'words', '']
&gt;&gt;&gt; re.split('([\W]+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
&gt;&gt;&gt; re.split('[\W]+', 'Words, words, words.', 1)
['Words', 'words, words.']
</PRE></DIV>
<P>
<H2><A name=SECTION000620000000000000000>5.2 찾기와 바꾸기</A> </H2>
<P>또다른 일반적인 작업은 패턴에 일치하는 모든 것들을 발견해서, 다른 문자열로 치환하는 것이다. <TT 
class=method>sub()</TT> 메쏘드는 문자열이나 함수일 수 있는 교체 값과, 그리고 처리될 문자열을 취한다. 
<P>
<DL>
  <DT>
  <TABLE cellSpacing=0 cellPadding=0>
    
    <TR vAlign=baseline>
      <TD><NOBR><B><A name=l2h-12><TT class=method>sub</TT></A></B>(</NOBR></TD>
      <TD><VAR><FONT face=Times>replacement, string</FONT></VAR><BIG><FONT 
        size=4>[</FONT></BIG><VAR><FONT face=Times>, count</FONT><CODE> = 
        0</CODE></VAR><BIG><FONT size=4>]</FONT></BIG>)</TD></TR></TABLE>
  <DD>문자열(<VAR><FONT face=Times>string</FONT></VAR>)에서 RE가 가장 왼쪽에서 중첩되지 않게 출현할 
  때마다 대체물(<VAR><FONT face=Times>replacement</FONT></VAR>)로 대치하여 얻은 문자열을 반환한다. 
  패턴이 발견되지 않으면, 문자열(<VAR><FONT face=Times>string</FONT></VAR>)은 그대로 반환된다. 
  <P>선택적인 인수 <VAR><FONT face=Times>count</FONT></VAR>는 패턴의 출현이 대치될 최대 횟수이다; 
  <VAR><FONT face=Times>count</FONT></VAR>는 비-음수의 정수가 되어야 한다. 기본 값인 0은 모든 출현을 
  대치한다는 뜻이다. </P></DD></DL>
<P>다음은 <TT class=method>sub()</TT> 메쏘드를 사용하는 간단한 예이다. 색깔 이름들을 단어 "<TT 
class=samp>colour</TT>"로 치환한다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile( '(blue|white|red)')
&gt;&gt;&gt; p.sub( 'colour', 'blue socks and red shoes')
'colour socks and colour shoes'
&gt;&gt;&gt; p.sub( 'colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'
</PRE></DIV>
<P><TT class=method>subn()</TT> 메쏘드는 똑 같은 일을 하지만, 새로운 문자열 값과 수행된 교체 횟수를 담은 2-터플을 
반환한다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile( '(blue|white|red)')
&gt;&gt;&gt; p.subn( 'colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
&gt;&gt;&gt; p.subn( 'colour', 'no colours at all')
('no colours at all', 0)
</PRE></DIV>
<P>빈 일치는 이전의 일치에 바로 연이어서 일어나지 않을 때만 교체된다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('x*')
&gt;&gt;&gt; p.sub('-', 'abxd')
'-a-b-d-'
</PRE></DIV>
<P>만약 <VAR><FONT face=Times>replacement</FONT></VAR>가 문자열이면, 그 안에 있는 역사선은 모두 
처리된다. 다시 말해, "<TT class=samp>\n</TT>"은 한개의 새줄문자로 변환되고, "<TT class=samp>\r</TT>"은 
나르게복귀문자로 변환된다. 등등. "<TT class=samp>\j</TT>"와 같이 잘 모르는 피신 문자들은 그대로 둔다. "<TT 
class=samp>\6</TT>"와 같은 역참조는 RE에서 상응하는 그룹에 일치된 하부문자열로 교체된다. 이렇게 하면 결과로 나오는 대체 
문자열에 원래 텍스트의 일부를 짜넣을 수 있다. 
<P>다음 예제는 "<TT class=samp>{</TT>", "<TT class=samp>}</TT>"에 둘러싸인 문자열이 다음에 따라오는 
"<TT class=samp>section</TT>"이라는 단어에 일치하면, "<TT class=samp>section</TT>"을 "<TT 
class=samp>subsection</TT>"으로 바꾼다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First} section{second}')
'subsection{First} subsection{second}'
</PRE></DIV>
<P><TT class=regexp>(?P&lt;name&gt;...)</TT> 구문으로 정의되어 이름붙은 그룹을 참조하는데 사용되는 구문도 
있다. "<TT class=samp>\g&lt;name&gt;</TT>"은 "<TT class=samp>name</TT>"이라는 이름의 그룹에 
일치된 하부문자열을 사용하고, "<TT class=samp>\g&lt;<VAR><FONT 
face=Times>number</FONT></VAR>&gt;</TT>"은 그에 상응하는 그룹 번호를 사용한다. 그러므로 "<TT 
class=samp>\g&lt;2&gt;</TT>"는 "<TT class=samp>\2</TT>"와 동등하지만, "<TT 
class=samp>\g&lt;2&gt;0</TT>"와 같은 대체 문자열에서 명료하다. ("<TT class=samp>\20</TT>"는 다음에 
기호문자 "<TT class=character>0</TT>"이 따라오는 그룹 2번에 대한 참조가 아니라 그룹 20에 대한 참조로 번역된다.) 
다음의 치환은 모두 동등하지만, 대체 문자열의 세가지 변형을 모두 사용한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('section{ (?P&lt;name&gt; [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;1&gt;}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;name&gt;}','section{First}')
'subsection{First}'
</PRE></DIV>
<P><VAR><FONT face=Times>replacement</FONT></VAR>는 함수가 될 수도 있는데, 이것이 훨씬 더 통제가 
가능하다. <VAR><FONT face=Times>replacement</FONT></VAR>가 함수라면, 그 함수는 <VAR><FONT 
face=Times>pattern</FONT></VAR>이 중첩되지 않고 출현할 때마다 호출된다. 각 호출마다, 그 함수에 그 일치에 대한 
<TT class=class>MatchObject</TT> 인수가 건네지고 이 정보를 사용하여 원하는 대체 문자열을 계산하고 그것을 반환한다. 
<P>다음 예제에서, 교체 함수는 십진수를 십육진수로 번역한다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; def hexrepl( match ):
...     "Return the hex string for a decimal number"
...     value = int( match.group() )
...     return hex(value)
...
&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
</PRE></DIV>
<P>모듈 수준의 <TT class=function>re.sub()</TT> 함수를 사용할 때, 패턴이 첫 인수로 건네진다. 패턴은 문자열이거나 
<TT class=class>RegexObject</TT>일 수 있다; 정규 표현식 표식을 지정할 필요가 있으면, <TT 
class=class>RegexObject</TT>를 첫 인수로 사용하거나, 또는 임베드된 수식자를 패턴에 사용해야 한다. 예를 들어 
<CODE>sub("(?i)b+", "x", "bbbb BBBB")</CODE>는 <CODE>'x x'</CODE>를 반환한다. 
<P>
<H1><A name=SECTION000700000000000000000>6 일반적인 문제들</A> </H1>
<P>정규 표현식은 어떤 곳에는 강력한 도구이지만, 어떤 면에서 그 행위는 직관적이지 않고 때로는 예상대로 행위하지 않는다. 이 섹션에서는 가장 
흔하게 빠지는 함정들을 지적해 보겠다. 
<P>
<H2><A name=SECTION000710000000000000000>6.1 문자열 메쏘드를 사용하자</A> </H2>
<P>때로는 <TT class=module>re</TT> 모듈을 사용하는 것이 실수인 경우가 있다. 고정된 문자열을 일치시키려고 하거나, 또는 
한 문자짜리 부류를 일치시키고 싶다면, 그리고 <TT class=constant>IGNORECASE</TT> 표식과 같은 <TT 
class=module>re</TT>의 특징을 사용하고 있지 않으면, 정규 표현식의 힘이 모두 필요하지는 않을 것이다. 문자열은 고정된 문자열로 
연산을 수행하는 여러 메쏘드들이 있다. 그리고 보통 더 빠르다. 왜냐하면 그 구현이 커다란, 더 일반적인 정규 표현식 엔진 대신에 그 목적으로 
최적화된 단일한 작은 C 회돌이이기 때문이다. 
<P>한 가지 예는 단일한 고정 문자열을 다른 문자열로 치환하는 것이다; 예를 들어, "<TT class=samp>word</TT>"를 "<TT 
class=samp>deed</TT>"로 교체하고 싶다고 하자. <CODE>re.sub()</CODE>이 바로 이런 일을 위해 사용될 만한 
함수처럼 보이지만 <TT class=method>replace()</TT> 메쏘드를 고려하자. 주목할 것은 <TT 
class=function>replace()</TT>는 단어 안에 들은 "<TT class=samp>word</TT>"도 대체한다. "<TT 
class=samp>swordfish</TT>"를 "<TT class=samp>sdeedfish</TT>"로 바꾸지만, 본래의 RE <TT 
class=regexp>word</TT>도 역시 그럴 것이다. (단어의 일부에 치환을 수행하는 것을 피하려면, 패턴은 "<TT 
class=samp>word</TT>" 양쪽에 단어 경계가 있어야 하기 때문에 <TT class=regexp>\bword\b</TT>로 되어야 
한다. 이는 <TT class=method>replace</TT>의 능력을 넘어서는 작업이다.) 
<P>또다른 흔한 작업은 문자열에서 하나의 문자가 출현할 때마다 지우거나, 그것을 또다른 하나의 문자로 교체하는 것이다. 이런 작업은 
<CODE>re.sub('\n', ' ', S)</CODE>와 같은 것으로 수행할 수 있지만, <TT 
class=method>translate()</TT>가 두 작업 모두를 할 수 있으며 다른 어떤 정규 표현식 연산보다 더 빠를 것이다. 
<P>간단히 말해, <TT class=module>re</TT> 모듈에 의존하기 전에, 먼저 문제가 더 빠르고 더 간단한 문자열 메쏘드로 해결될 
수 있는지 생각해 보자. 
<P>
<H2><A name=SECTION000720000000000000000>6.2 match() 대 search()</A> </H2>
<P><TT class=function>match()</TT> 함수는 오직 RE가 문자열의 처음에서 일치하는지만 점검하는데, 반면에 <TT 
class=function>search()</TT>는 문자열을 따라가며 일치를 찾는다. 이 차이를 염두에 두는 것이 중요하다. <TT 
class=function>match()</TT>가 성공적인 일치를 보고하면 그 위치는 언제나 0이다; 일치가 0에서 시작되지 않으면, <TT 
class=function>match()</TT>는 보고하지 <I>않는다</I>. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match('super', 'superstition').span()  
(0, 5)
&gt;&gt;&gt; print re.match('super', 'insuperable')    
None
</PRE></DIV>
<P>반면에, <TT class=function>search()</TT>는 문자열을 주욱 앞으로 ?어가며 자신이 발견한 첫 일치를 보고한다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('super', 'superstition').span()
(0, 5)
&gt;&gt;&gt; print re.search('super', 'insuperable').span()
(2, 7)
</PRE></DIV>
<P>가끔 그냥 RE 앞에 <TT class=regexp>.*</TT>를 추가해서 <TT 
class=function>re.match()</TT>를 계속 사용하고 싶은 유혹이 들때가 있다. 이런 유혹을 떨쳐 버리고 대신에 <TT 
class=function>re.search()</TT>를 사용하자. 정규 표현식 컴파일러는 일치를 찾는 과정의 속도를 높이기 위해 RE에 
몇가지 분석을 한다. 그런 분석중에 한가지는 일치하는 첫 문자가 무엇이어야 하는지 가늠하는 것이 있다; 예를 들어, <TT 
class=regexp>Crow</TT>는 "<TT class=character>C</TT>"로 시작하는 문자열과 일치해야 한다. 그 분석 
덕분에 엔진은 재빨리 문자열을 ?으며 시작 문자를 찾고, "<TT class=character>C</TT>"가 발견될 때만 완전한 일치를 
시도한다. 
<P><TT class=regexp>.*</TT>를 덧붙이면 이런 최적화가 불가능해져서, 문자열의 끝까지 ?어야 하고 다시 돌아와 나머지 RE에 
대하여 일치를 찾아야 한다. 대신에 <TT class=function>re.search()</TT>를 사용하자. 
<P>
<H2><A name=SECTION000730000000000000000>6.3 탐욕적 탐색 대 비-탐욕적 탐색</A> </H2>
<P><TT class=regexp>a*</TT>에서와 같이 정규 표현식을 반복할 때, 결과 행위는 가능하면 많은 패턴을 소비하는 것이다. 이 
사실은 HTML 태그 주위의 각 괄호와 같은 한짝을 이룬 구분자를 일치하려고 시도할 때 자주 문다. 한개의 HTML 태그에 일치시키는 순수한 
패턴은 <TT class=regexp>.*</TT>의 탐욕적인 본성 때문에 작동하지 않는다. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; s = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'
&gt;&gt;&gt; len(s)
32
&gt;&gt;&gt; print re.match('&lt;.*&gt;', s).span()
(0, 32)
&gt;&gt;&gt; print re.match('&lt;.*&gt;', s).group()
&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;
</PRE></DIV>
<P>RE는 "<TT class=samp>&lt;html&gt;</TT>" 안에서 "<TT class=character>&lt;</TT>"에 
일치하고, <TT class=regexp>.*</TT>는 나머지 문자열을 소비한다. 그렇지만, 여전히 RE에는 더 남아있고, <TT 
class=regexp>&gt;</TT>는 문자열의 마지막에 일치할 수 없기 때문에, 정규 표현식 엔진은 <TT 
class=regexp>&gt;</TT>에 대하여 일치를 발견할 때까지 문자를 하나하나 역추적한다. 최종적인 일치는 "<TT 
class=samp>&lt;html&gt;</TT>"에 있는 "<TT class=character>&lt;</TT>"에서부터 "<TT 
class=samp>&lt;/title&gt;</TT>"에 있는 "<TT class=character>&gt;</TT>"에까지 확장되는데, 이는 
원하는 바가 아니다. 
<P>이 경우, 해결책은 비-탐욕적 수식자를 사용하는 것이다. 여기에는 <TT class=regexp>*?</TT>, <TT 
class=regexp>+?</TT>, <TT class=regexp>??</TT>, 또는 <TT class=regexp>{<VAR><FONT 
face=Times>m</FONT></VAR>,<VAR><FONT face=Times>n</FONT></VAR>}?</TT>이 있는데, 이는 
가능하면 <I>적게</I> 텍스트와 일치한다. 위의 예제에서, "<TT class=character>&gt;</TT>"는 첫 "<TT 
class=character>&lt;</TT>" 일치 다음에 바로 시도되는데, 그리고 실패하면, 엔진은 한 번에 한 문자씩 앞으로 나아가면서 각 
단계마다 "<TT class=character>&gt;</TT>"를 시도한다. 이렇게 하면 올바른 결과를 얻는다: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match('&lt;.*?&gt;', s).group()
&lt;html&gt;
</PRE></DIV>
<P>(주목할 것은 HTML이나 XML을 정규 표현식으로 해석하는 작업은 고통스럽다는 것이다. 순간-대충 만든 패턴이 일반적인 사례들은 
처리하겠지만, HTML과 XML은 특별한 사례라서 확실한 정규 표현식도 망가트린다; 가능한 모든 사례들을 다룰 만한 정규 표현식을 완성할 때 
쯤이면, 그 패턴은 <I>아주</I> 복잡해질 것이다. 그런 작업에는 HTML이나 XML 해석기를 이용하자.) 
<P>
<H2><A name=SECTION000740000000000000000>6.4 re.VERBOSE를 사용하지 않으면</A> </H2>
<P>지금까지 어쩌면 정규 표현식이 아주 간결한 표기법일 수 있지만, 읽기가 아주 어렵다는 것을 눈치챘을 수도 있겠다. 적당하게 복잡한 RE는 
역사선, 괄호, 그리고 메타문자의 기다란 집단이 될 수 있어서, 읽고 이해하기에 아주 어렵게 된다. 
<P>그런 RE에 대해서, 정규 표현식을 컴파일 할 때 <CODE>re.VERBOSE</CODE> 표식을 지정하면 정규 표현식을 보다 명료하게 
형식화할 수 있기 때문 에 도움이 될 수 있다. 
<P><CODE>re.VERBOSE</CODE> 표식은 여러가지 효과가 있다. 정규 표현식에서 문자 범주 안에 <I>들어 있지 않은</I> 
공백은 무시된다. 이는 곧 <TT class=regexp>dog | cat</TT>과 같은 표현식이 좀 읽기에 피곤한 <TT 
class=regexp>dog|cat</TT>과 동등하지만, <TT class=regexp>[a b]</TT>는 여전히 문자 "<TT 
class=character>a</TT>", "<TT class=character>b</TT>", 또는 스페이스에 일치할 것이라는 뜻이다. 
게다가, RE 안에 주석도 달 수 있다; 주석은 "<TT class=samp>#</TT>" 문자로 시작하여 다음의 새줄문자까지 확장된다. 
삼중-따옴표 문자열과 함께 사용하면, 보다 깔끔하게 RE의 모습을 다듬을 수 있다: 
<P>
<DIV class=verbatim><PRE>pat = re.compile(r"""
 \s*                 # 앞의 공백을 건너뛴다
 (?P&lt;header&gt;[^:]+)   # 머리부 이름
 \s* :               # 공백, 그리고 쌍점
 (?P&lt;value&gt;.*?)      # 머리부의 값 -- *? 
                     # 다음에 따르는 공백을 없애는데 사용된다
 \s*$                # 줄끝까지 이끌리는 공백
""", re.VERBOSE)
</PRE></DIV>
<P>이것이 다음보다 훨씬 더 읽기 쉽다: 
<P>
<DIV class=verbatim><PRE>pat = re.compile(r"\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$")
</PRE></DIV>
<P>
<H1><A name=SECTION000800000000000000000>7 되먹임</A> </H1>
<P>정규 표현식은 복잡한 주제이다. 이 문서가 이해하는데 도움이 되었는지 모르겠다. 이해가 안가는 부분이 있거나 여기에서 다루지 않은 문제가 
있다면, 본인에게 개선을 위한 제안을 보내주기를 바란다. 
<P>정규 표현식에 관한 가장 완벽한 책은 오라일리(O'Reilly)에서 발간한 제프리 프리들(Jeffrey Friedl)의 <EM 
class=citetitle>정규 표현식 정복(Mastering Regular Expressions)</EM>일 것이다. 불행하게도, 거의 펄과 
자바 취향의 정규 표현식에 집중할 뿐 파이썬에 관해서는 전혀 다루지 않는다. 그래서 파이썬으로 프로그래밍하는데 참조하기에는 별로 쓸모가 없을 
것이다. (첫 판은 파이썬에서 이제 폐기된 <TT class=module>regex</TT> 모듈을 다루었고, 이는 별로 도움이 되지 못할 
것이다.) 
<P>
<H1><A name=SECTION000900000000000000000>이 문서에 대하여 ...</A> </H1><STRONG>정규 표현식 
HOWTO</STRONG> 
<P>이 문서는 <A href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000bb>LaTeX2<TT>HTML</TT></FONT></U></A> 번역기를 사용하여 만들어졌다. </P>
<P><A href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000bb>LaTeX2<TT>HTML</TT></FONT></U></A>은 다음에 복사권이 있다: Copyright ⓒ 1993, 
1994, 1995, 1996, 1997, <A 
href="http://cbl.leeds.ac.uk/nikos/personal.html"><U><FONT color=#0000bb>Nikos 
Drakos</FONT></U></A>, Computer Based Learning Unit, University of Leeds, and 
Copyright ⓒ 1997, 1998, <A href="http://www.maths.mq.edu.au/~ross/"><U><FONT 
color=#0000bb>Ross Moore</FONT></U></A>, Mathematics Department, Macquarie 
University, Sydney. </P>
<P><A href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000bb>LaTeX2<TT>HTML</TT></FONT></U></A>을 파이썬 문서화에 적용하면서 프레드 드레이크(Fred 
L. Drake, Jr)가 상당히 손을 보았다. 원래의 항해 아이콘은 크리스토퍼 페트릴리(Christopher Petrilli)가 공헌하였다. 
</P>
<HR>
<SPAN class=release-info><EM>Release 0.05.</EM></SPAN> </DIV>
</BODY></HTML>
