<HTML><HEAD><META http-equiv=Content-Type content="text/html; charset=euc-kr">
<style type="text/css">
<!--
BODY,TD,SELECT,input,DIV,form,TEXTAREA,option {font-size:9pt; font-family:verdana;color:333333}
A:link {color:#4077a0;text-decoration:none;font-weight: bold}
A:visited {color:#4077a0;text-decoration:none;font-weight: bold}
A:hover{color:#990000;text-decoration:none;font-weight: bold}
--></style></HEAD>
<BODY>
<table cellSpacing=1 cellPadding=4 width=500 bgColor=#3c62c6 border=0>
  <tr>
    <td width=600>
      <div><STRONG><FONT color=#ffffff>▶제목/참고</FONT></STRONG> </div></td></tr>
  <tr bgColor=#ffffff>
    <td>
      <div></div>
      <DIV>Title: </DIV>      
      <div>&nbsp;</div>
      <DIV>&nbsp;</DIV>
      <DIV>From: </DIV>
    </td></tr></table>
<div>
<DIV class=navigation>
<TABLE cellSpacing=2 cellPadding=0 width="100%" align=center>
  
  <TR>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD align=middle width="100%">Regular Expression HOWTO</TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD></TR></TABLE><BR>
<HR>
</DIV><!--End of Navigation Panel-->
<DIV class=titlepage>
<CENTER>
<H1>Regular Expression HOWTO</H1>
<P><B><FONT size=+2>A.M. Kuchling</FONT></B></P>
<P><SPAN class=email>amk@amk.ca</SPAN></P>
<P></CENTER></P></DIV>
<P>
<H3>Abstract:</H3>
<DIV class=ABSTRACT>This document is an introductory tutorial to using regular 
expressions in Python with the <TT class=module>re</TT> module. It provides a 
gentler introduction than the corresponding section in the Library Reference. 
<P>This document is available from <A class=url 
href="http://www.amk.ca/python/howto"><U><FONT 
color=#0000ff>http://www.amk.ca/python/howto</FONT></U></A>. 
<P></P></DIV>
<P>
<P><BR><BR>
<H2><A name=SECTION000100000000000000000>Contents</A> </H2><!--Table of Contents-->
<UL class=TofC>
  <LI><A href="regex.html"><U><FONT color=#0000ff>1 Introduction</FONT></U></A> 
  <LI><A href="regex.html#SECTION000300000000000000000"><U><FONT color=#0000ff>2 
  Simple Patterns</FONT></U></A> 
  <UL>
    <LI><A href="regex.html#SECTION000310000000000000000"><U><FONT 
    color=#0000ff>2.1 Matching Characters</FONT></U></A> 
    <LI><A href="regex.html#SECTION000320000000000000000"><U><FONT 
    color=#0000ff>2.2 Repeating Things</FONT></U></A> </LI></UL>
  <LI><A href="regex.html#SECTION000400000000000000000"><U><FONT color=#0000ff>3 
  Using Regular Expressions</FONT></U></A> 
  <UL>
    <LI><A href="regex.html#SECTION000410000000000000000"><U><FONT 
    color=#0000ff>3.1 Compiling Regular Expressions</FONT></U></A> 
    <LI><A href="regex.html#SECTION000420000000000000000"><U><FONT 
    color=#0000ff>3.2 The Backslash Plague</FONT></U></A> 
    <LI><A href="regex.html#SECTION000430000000000000000"><U><FONT 
    color=#0000ff>3.3 Performing Matches</FONT></U></A> 
    <LI><A href="regex.html#SECTION000440000000000000000"><U><FONT 
    color=#0000ff>3.4 Module-Level Functions</FONT></U></A> 
    <LI><A href="regex.html#SECTION000450000000000000000"><U><FONT 
    color=#0000ff>3.5 Compilation Flags</FONT></U></A> </LI></UL>
  <LI><A href="regex.html#SECTION000500000000000000000"><U><FONT color=#0000ff>4 
  More Pattern Power</FONT></U></A> 
  <UL>
    <LI><A href="regex.html#SECTION000510000000000000000"><U><FONT 
    color=#0000ff>4.1 More Metacharacters</FONT></U></A> 
    <LI><A href="regex.html#SECTION000520000000000000000"><U><FONT 
    color=#0000ff>4.2 Grouping</FONT></U></A> 
    <LI><A href="regex.html#SECTION000530000000000000000"><U><FONT 
    color=#0000ff>4.3 Non-capturing and Named Groups</FONT></U></A> 
    <LI><A href="regex.html#SECTION000540000000000000000"><U><FONT 
    color=#0000ff>4.4 Lookahead Assertions</FONT></U></A> </LI></UL>
  <LI><A href="regex.html#SECTION000600000000000000000"><U><FONT color=#0000ff>5 
  Modifying Strings</FONT></U></A> 
  <UL>
    <LI><A href="regex.html#SECTION000610000000000000000"><U><FONT 
    color=#0000ff>5.1 Splitting Strings</FONT></U></A> 
    <LI><A href="regex.html#SECTION000620000000000000000"><U><FONT 
    color=#0000ff>5.2 Search and Replace</FONT></U></A> </LI></UL>
  <LI><A href="regex.html#SECTION000700000000000000000"><U><FONT color=#0000ff>6 
  Common Problems</FONT></U></A> 
  <UL>
    <LI><A href="regex.html#SECTION000710000000000000000"><U><FONT 
    color=#0000ff>6.1 Use String Methods</FONT></U></A> 
    <LI><A href="regex.html#SECTION000720000000000000000"><U><FONT 
    color=#0000ff>6.2 match() versus search()</FONT></U></A> 
    <LI><A href="regex.html#SECTION000730000000000000000"><U><FONT 
    color=#0000ff>6.3 Greedy versus Non-Greedy</FONT></U></A> 
    <LI><A href="regex.html#SECTION000740000000000000000"><U><FONT 
    color=#0000ff>6.4 Not Using re.VERBOSE</FONT></U></A> </LI></UL>
  <LI><A href="regex.html#SECTION000800000000000000000"><U><FONT color=#0000ff>7 
  Feedback</FONT></U></A> 
  <LI><A href="regex.html#SECTION000900000000000000000"><U><FONT 
  color=#0000ff>About this document ...</FONT></U></A> </LI></UL><!--End of Table of Contents-->
<P>
<H1><A name=SECTION000200000000000000000>1 Introduction</A> </H1>
<P>The <TT class=module>re</TT> module was added in Python 1.5, and provides 
Perl-style regular expression patterns. Earlier versions of Python came with the 
<TT class=module>regex</TT> module, which provides Emacs-style patterns. 
Emacs-style patterns are slightly less readable and don't provide as many 
features, so there's not much reason to use the <TT class=module>regex</TT> 
module when writing new code, though you might encounter old code that uses it. 
<P>Regular expressions (or REs) are essentially a tiny, highly specialized 
programming language embedded inside Python and made available through the <TT 
class=module>re</TT> module. Using this little language, you specify the rules 
for the set of possible strings that you want to match; this set might contain 
English sentences, or e-mail addresses, or TeX commands, or anything you like. 
You can then ask questions such as ``Does this string match the pattern?'', or 
``Is there a match for the pattern anywhere in this string?''. You can also use 
REs to modify a string or to split it apart in various ways. 
<P>Regular expression patterns are compiled into a series of bytecodes which are 
then executed by a matching engine written in C. For advanced use, it may be 
necessary to pay careful attention to how the engine will execute a given RE, 
and write the RE in a certain way in order to produce bytecode that runs faster. 
Optimization isn't covered in this document, because it requires that you have a 
good understanding of the matching engine's internals. 
<P>The regular expression language is relatively small and restricted, so not 
all possible string processing tasks can be done using regular expressions. 
There are also tasks that <I>can</I> be done with regular expressions, but the 
expressions turn out to be very complicated. In these cases, you may be better 
off writing Python code to do the processing; while Python code will be slower 
than an elaborate regular expression, it will also probably be more 
understandable. 
<P>
<H1><A name=SECTION000300000000000000000>2 Simple Patterns</A> </H1>
<P>We'll start by learning about the simplest possible regular expressions. 
Since regular expressions are used to operate on strings, we'll begin with the 
most common task: matching characters. 
<P>For a detailed explanation of the computer science underlying regular 
expressions (deterministic and non-deterministic finite automata), you can refer 
to almost any textbook on writing compilers. 
<P>
<H2><A name=SECTION000310000000000000000>2.1 Matching Characters</A> </H2>
<P>Most letters and characters will simply match themselves. For example, the 
regular expression <TT class=regexp>test</TT> will match the string "<TT 
class=samp>test</TT>" exactly. (You can enable a case-insensitive mode that 
would let this RE match "<TT class=samp>Test</TT>" or "<TT class=samp>TEST</TT>" 
as well; more about this later.) 
<P>There are exceptions to this rule; some characters are special, and don't 
match themselves. Instead, they signal that some out-of-the-ordinary thing 
should be matched, or they affect other portions of the RE by repeating them. 
Much of this document is devoted to discussing various metacharacters and what 
they do. 
<P>Here's a complete list of the metacharacters; their meanings will be 
discussed in the rest of this HOWTO. 
<P>
<DIV class=verbatim><PRE>. ^ $ * + ? { [ ] \ | ( )
</PRE></DIV>
<P>The first metacharacters we'll look at are "<TT class=samp>[</TT>" and "<TT 
class=samp>]</TT>". They're used for specifying a character class, which is a 
set of characters that you wish to match. Characters can be listed individually, 
or a range of characters can be indicated by giving two characters and 
separating them by a "<TT class=character>-</TT>". For example, <TT 
class=regexp>[abc]</TT> will match any of the characters "<TT 
class=samp>a</TT>", "<TT class=samp>b</TT>", or "<TT class=samp>c</TT>"; this is 
the same as <TT class=regexp>[a-c]</TT>, which uses a range to express the same 
set of characters. If you wanted to match only lowercase letters, your RE would 
be <TT class=regexp>[a-z]</TT>. 
<P>Metacharacters are not active inside classes. For example, <TT 
class=regexp>[akm$]</TT> will match any of the characters "<TT 
class=character>a</TT>", "<TT class=character>k</TT>", "<TT 
class=character>m</TT>", or "<TT class=character>$</TT>"; "<TT 
class=character>$</TT>" is usually a metacharacter, but inside a character class 
it's stripped of its special nature. 
<P>You can match the characters not within a range by <I 
class=dfn>complementing</I> the set. This is indicated by including a "<TT 
class=character>^</TT>" as the first character of the class; "<TT 
class=character>^</TT>" elsewhere will simply match the "<TT 
class=character>^</TT>" character. For example, <CODE>[^5]</CODE> will match any 
character except "<TT class=character>5</TT>". 
<P>Perhaps the most important metacharacter is the backslash, "<TT 
class=samp>\</TT>". As in Python string literals, the backslash can be followed 
by various characters to signal various special sequences. It's also used to 
escape all the metacharacters so you can still match them in patterns; for 
example, if you need to match a "<TT class=samp>[</TT>" or "<TT 
class=samp>\</TT>", you can precede them with a backslash to remove their 
special meaning: <TT class=regexp>\[</TT> or <TT class=regexp>\\</TT>. 
<P>Some of the special sequences beginning with "<TT class=character>\</TT>" 
represent predefined sets of characters that are often useful, such as the set 
of digits, the set of letters, or the set of anything that isn't whitespace. The 
following predefined special sequences are available: 
<P>
<DL compact>
  <DT><CODE>\d</CODE> 
  <DD>Matches any decimal digit; this is equivalent to the class <TT 
  class=regexp>[0-9]</TT>. 
  <P></P>
  <DT><CODE>\D</CODE> 
  <DD>Matches any non-digit character; this is equivalent to the class 
  <CODE>[^0-9]</CODE>. 
  <P></P>
  <DT><CODE>\s</CODE> 
  <DD>Matches any whitespace character; this is equivalent to the class <TT 
  class=regexp>[ \t\n\r\f\v]</TT>. 
  <P></P>
  <DT><CODE>\S</CODE> 
  <DD>Matches any non-whitespace character; this is equivalent to the class 
  <CODE>[^ \t\n\r\f\v]</CODE>. 
  <P></P>
  <DT><CODE>\w</CODE> 
  <DD>Matches any alphanumeric character; this is equivalent to the class <TT 
  class=regexp>[a-zA-Z0-9_]</TT>. 
  <P></P>
  <DT><CODE>\W</CODE> 
  <DD>Matches any non-alphanumeric character; this is equivalent to the class 
  <CODE>[^a-zA-Z0-9_]</CODE>. </DD></DL>
<P>These sequences can be included inside a character class. For example, <TT 
class=regexp>[\s,.]</TT> is a character class that will match any whitespace 
character, or "<TT class=character>,</TT>" or "<TT class=character>.</TT>". 
<P>The final metacharacter in this section is <TT class=regexp>.</TT>. It 
matches anything except a newline character, and there's an alternate mode 
(<CODE>re.DOTALL</CODE>) where it will match even a newline. "<TT 
class=character>.</TT>" is often used where you want to match ``any character''. 

<P>
<H2><A name=SECTION000320000000000000000>2.2 Repeating Things</A> </H2>
<P>Being able to match varying sets of characters is the first thing regular 
expressions can do that isn't already possible with the methods available on 
strings. However, if that was the only additional capability of regexes, they 
wouldn't be much of an advance. Another capability is that you can specify that 
portions of the RE must be repeated a certain number of times. 
<P>The first metacharacter for repeating things that we'll look at is <TT 
class=regexp>*</TT>. <TT class=regexp>*</TT> doesn't match the literal character 
"<TT class=samp>*</TT>"; instead, it specifies that the previous character can 
be matched zero or more times, instead of exactly once. 
<P>For example, <TT class=regexp>ca*t</TT> will match "<TT class=samp>ct</TT>" 
(0 "<TT class=samp>a</TT>"characters), "<TT class=samp>cat</TT>" (1 "<TT 
class=samp>a</TT>"), "<TT class=samp>caaat</TT>" (3 "<TT 
class=samp>a</TT>"characters), and so forth. The RE engine has various internal 
limitations stemming from the size of C's <CODE>int</CODE> type, that will 
prevent it from matching over 2 billion "<TT class=samp>a</TT>" characters; you 
probably don't have enough memory to construct a string that large, so you 
shouldn't run into that limit. 
<P>Repetitions such as <TT class=regexp>*</TT> are <I class=dfn>greedy</I>; when 
repeating a RE, the matching engine will try to repeat it as many times as 
possible. If later portions of the pattern don't match, the matching engine will 
then back up and try again with few repetitions. 
<P>A step-by-step example will make this more obvious. Let's consider the 
expression <TT class=regexp>a[bcd]*b</TT>. This matches the letter "<TT 
class=character>a</TT>", zero or more letters from the class <CODE>[bcd]</CODE>, 
and finally ends with a "<TT class=character>b</TT>". Now imagine matching this 
RE against the string "<TT class=samp>abcbd</TT>". 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Step</B>&nbsp;</TH>
    <TH align=left><B>Matched</B>&nbsp;</TH>
    <TH align=left><B>Explanation</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle>1</TD>
    <TD align=left><CODE>a</CODE></TD>
    <TD align=left>The <TT class=regexp>a</TT> in the RE matches.</TD>
  <TR>
    <TD vAlign=baseline align=middle>2</TD>
    <TD align=left><CODE>abcbd</CODE></TD>
    <TD align=left>The engine matches <TT class=regexp>[bcd]*</TT>, going as 
      far as it can, which is to the end of the string.</TD>
  <TR>
    <TD vAlign=baseline align=middle>3</TD>
    <TD align=left><I>Failure</I></TD>
    <TD align=left>The engine tries to match <TT class=regexp>b</TT>, but the 
      current position is at the end of the string, so it fails.</TD>
  <TR>
    <TD vAlign=baseline align=middle>4</TD>
    <TD align=left><CODE>abcb</CODE></TD>
    <TD align=left>Back up, so that <TT class=regexp>[bcd]*</TT> matches one 
      less character.</TD>
  <TR>
    <TD vAlign=baseline align=middle>5</TD>
    <TD align=left><I>Failure</I></TD>
    <TD align=left>Try <TT class=regexp>b</TT> again, but the current position 
      is at the last character, which is a "<TT class=character>d</TT>".</TD>
  <TR>
    <TD vAlign=baseline align=middle>6</TD>
    <TD align=left><CODE>abc</CODE></TD>
    <TD align=left>Back up again, so that <TT class=regexp>[bcd]*</TT> is only 
      matching "<TT class=samp>bc</TT>".</TD>
  <TR>
    <TD vAlign=baseline align=middle>6</TD>
    <TD align=left><CODE>abcb</CODE></TD>
    <TD align=left>Try <TT class=regexp>b</TT> again. This time but the 
      character at the current position is "<TT class=character>b</TT>", so it 
      succeeds.</TD></TR></TBODY></TABLE>
<P>The end of the RE has now been reached, and it has matched "<TT 
class=samp>abcb</TT>". This demonstrates how the matching engine goes as far as 
it can at first, and if no match is found it will then progressively back up and 
retry the rest of the RE again and again. It will back up until it has tried 
zero matches for <TT class=regexp>[bcd]*</TT>, and if that subsequently fails, 
the engine will conclude that the string doesn't match the RE at all. 
<P>Another repeating metacharacter is <TT class=regexp>+</TT>, which matches one 
or more times. Pay careful attention to the difference between <TT 
class=regexp>*</TT> and <TT class=regexp>+</TT>; <TT class=regexp>*</TT> matches 
<I>zero</I> or more times, so whatever's being repeated may not be present at 
all, while <TT class=regexp>+</TT> requires at least <I>one</I> occurrence. To 
use a similar example, <TT class=regexp>ca+t</TT> will match "<TT 
class=samp>cat</TT>" (1 "<TT class=samp>a</TT>"), "<TT class=samp>caaat</TT>" (3 
"<TT class=samp>a</TT>"'s), but won't match "<TT class=samp>ct</TT>". 
<P>There are two more repeating qualifiers. The question mark character, <TT 
class=regexp>?</TT>, matches either once or zero times; you can think of it as 
marking something as being optional. For example, <TT 
class=regexp>home-?brew</TT> matches either "<TT class=samp>homebrew</TT>" or 
"<TT class=samp>home-brew</TT>". 
<P>The most complicated repeated qualifier is <TT 
class=regexp>{<VAR>m</VAR>,<VAR>n</VAR>}</TT>, where <VAR>m</VAR> and 
<VAR>n</VAR> are decimal integers. This qualifier means there must be at least 
<VAR>m</VAR> repetitions, and at most <VAR>n</VAR>. For example, <TT 
class=regexp>a/{1,3}b</TT> will match "<TT class=samp>a/b</TT>", "<TT 
class=samp>a//b</TT>", and "<TT class=samp>a///b</TT>". It won't match "<TT 
class=samp>ab</TT>", which has no slashes, or "<TT class=samp>a////b</TT>", 
which has four. 
<P>You can omit either <VAR>m</VAR> or <VAR>n</VAR>; in that case, a reasonable 
value is assumed for the missing value. Omitting <VAR>m</VAR> is interpreted as 
a lower limit of 0, while omitting <VAR>n</VAR> results in an upper bound of 
infinity -- actually, the 2 billion limit mentioned earlier, but that might as 
well be infinity. 
<P>Readers of a reductionist bent may notice that the three other qualifiers can 
all be expressed using this notation. <TT class=regexp>{0,}</TT> is the same as 
<TT class=regexp>*</TT>, <TT class=regexp>{1,}</TT> is equivalent to <TT 
class=regexp>+</TT>, and <TT class=regexp>{0,1}</TT> is the same as <TT 
class=regexp>?</TT>. It's better to use <TT class=regexp>*</TT>, <TT 
class=regexp>+</TT>, or <TT class=regexp>?</TT> when you can, simply because 
they're shorter and easier to read. 
<P>
<H1><A name=SECTION000400000000000000000>3 Using Regular Expressions</A> </H1>
<P>Now that we've looked at some simple regular expressions, how do we actually 
use them in Python? The <TT class=module>re</TT> module provides an interface to 
the regular expression engine, allowing you to compile REs into objects and then 
perform matches with them. 
<P>
<H2><A name=SECTION000410000000000000000>3.1 Compiling Regular Expressions</A> 
</H2>
<P>Regular expressions are compiled into <TT class=class>RegexObject</TT> 
instances, which have methods for various operations such as searching for 
pattern matches or performing string substitutions. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('ab*')
&gt;&gt;&gt; print p
&lt;re.RegexObject instance at 80b4150&gt;
</PRE></DIV>
<P><TT class=function>re.compile()</TT> also accepts an optional 
<VAR>flags</VAR> argument, used to enable various special features and syntax 
variations. We'll go over the available settings later, but for now a single 
example will do: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)
</PRE></DIV>
<P>The RE is passed to <TT class=function>re.compile()</TT> as a string. REs are 
handled as strings because regular expressions aren't part of the core Python 
language, and no special syntax was created for expressing them. (There are 
applications that don't need REs at all, so there's no need to bloat the 
language specification by including them.) Instead, the <TT class=module>re</TT> 
module is simply a C extension module included with Python, just like the <TT 
class=module>socket</TT> or <TT class=module>zlib</TT> module. 
<P>Putting REs in strings keeps the Python language simpler, but has one 
disadvantage which is the topic of the next section. 
<P>
<H2><A name=SECTION000420000000000000000>3.2 The Backslash Plague</A> </H2>
<P>As stated earlier, regular expressions use the backslash character ("<TT 
class=character>\</TT>") to indicate special forms or to allow special 
characters to be used without invoking their special meaning. This conflicts 
with Python's usage of the same character for the same purpose in string 
literals. 
<P>Let's say you want to write a RE that matches the string "<TT 
class=samp>\section</TT>", which might be found in a <SPAN 
class=logo,LaTeX>L<SUP><SMALL><FONT size=2>A</FONT></SMALL></SUP>T<SMALL><FONT 
size=2>E</FONT></SMALL>X</SPAN> file. To figure out what to write in the program 
code, start with the desired string to be matched. Next, you must escape any 
backslashes and other metacharacters by preceding them with a backslash, 
resulting in the string "<TT class=samp>\\section</TT>". The resulting string 
that must be passed to <TT class=function>re.compile()</TT> must be 
<CODE>\\section</CODE>. However, to express this as a Python string literal, 
both backslashes must be escaped <I>again</I>. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Characters</B>&nbsp;</TH>
    <TH align=left><B>Stage</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>\section</CODE></TD>
    <TD align=left>Text string to be matched</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>\\section</CODE></TD>
    <TD align=left>Escaped backslash for <TT class=function>re.compile</TT></TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\\\section"</CODE></TD>
    <TD align=left>Escaped backslashes for a string 
literal</TD></TR></TBODY></TABLE>
<P>In short, to match a literal backslash, one has to write <CODE>'\\\\'</CODE> 
as the RE string, because the regular expression must be "<TT 
class=samp>\\</TT>", and each backslash must be expressed as "<TT 
class=samp>\\</TT>" inside a regular Python string literal. In REs that feature 
backslashes repeatedly, this leads to lots of repeated backslashes and makes the 
resulting strings difficult to understand. 
<P>The solution is to use Python's raw string notation for regular expressions; 
backslashes are not handled in any special way in a string literal prefixed with 
"<TT class=character>r</TT>", so <CODE>r"\n"</CODE> is a two-character string 
containing "<TT class=character>\</TT>" and "<TT class=character>n</TT>", while 
<CODE>"\n"</CODE> is a one-character string containing a newline. Frequently 
regular expressions will be expressed in Python code using this raw string 
notation. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Regular String</B>&nbsp;</TH>
    <TH align=middle><B>Raw string</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"ab*"</CODE></TD>
    <TD align=middle><CODE>r"ab*"</CODE></TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\\\section"</CODE></TD>
    <TD align=middle><CODE>r"\\section"</CODE></TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>"\\w+\\s+\\1"</CODE></TD>
    <TD align=middle><CODE>r"\w+\s+\1"</CODE></TD></TR></TBODY></TABLE>
<P>
<H2><A name=SECTION000430000000000000000>3.3 Performing Matches</A> </H2>
<P>Once you have an object representing a compiled regular expression, what do 
you do with it? <TT class=class>RegexObject</TT> instances have several methods 
and attributes. Only the most significant ones will be covered here; consult <A 
class=ulink href="http://www.python.org/doc/lib/module-re.html"><U><FONT 
color=#0000ff>the Library Reference</FONT></U></A> for a complete listing. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Method/Attribute</B>&nbsp;</TH>
    <TH align=left><B>Purpose</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>match()</CODE></TD>
    <TD align=left>Determine if the RE matches at the beginning of the 
    string.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>search()</CODE></TD>
    <TD align=left>Scan through a string, looking for any location where this 
      RE matches.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>findall()</CODE></TD>
    <TD align=left>Find all substrings where the RE matches, and returns them 
      as a list.</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>finditer()</CODE></TD>
    <TD align=left>Find all substrings where the RE matches, and returns them 
      as an iterator.</TD></TR></TBODY></TABLE>
<P><TT class=method>match()</TT> and <TT class=method>search()</TT> return 
<CODE>None</CODE> if no match can be found. If they're successful, a 
<CODE>MatchObject</CODE> instance is returned, containing information about the 
match: where it starts and ends, the substring it matched, and more. 
<P>You can learn about this by interactively experimenting with the <TT 
class=module>re</TT> module. If you have Tkinter available, you may also want to 
look at <SPAN class=file>Tools/scripts/redemo.py</SPAN>, a demonstration program 
included with the Python distribution. It allows you to enter REs and strings, 
and displays whether the RE matches or fails. <SPAN class=file>redemo.py</SPAN> 
can be quite useful when trying to debug a complicated RE. Phil Schwartz's <A 
class=ulink href="http://kodos.sourceforge.net"><U><FONT 
color=#0000ff>Kodos</FONT></U></A> is also an interactive tool for developing 
and testing RE patterns. This HOWTO will use the standard Python interpreter for 
its examples. 
<P>First, run the Python interpreter, import the <TT class=module>re</TT> 
module, and compile a RE: 
<P>
<DIV class=verbatim><PRE>Python 2.2.2 (#1, Feb 10 2003, 12:57:01)
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('[a-z]+')
&gt;&gt;&gt; p
&lt;_sre.SRE_Pattern object at 80c3c28&gt;
</PRE></DIV>
<P>Now, you can try matching various strings against the RE <TT 
class=regexp>[a-z]+</TT>. An empty string shouldn't match at all, since <TT 
class=regexp>+</TT> means 'one or more repetitions'. <TT 
class=method>match()</TT> should return <CODE>None</CODE> in this case, which 
will cause the interpreter to print no output. You can explicitly print the 
result of <TT class=method>match()</TT> to make this clear. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p.match("")
&gt;&gt;&gt; print p.match("")
None
</PRE></DIV>
<P>Now, let's try it on a string that it should match, such as "<TT 
class=samp>tempo</TT>". In this case, <TT class=method>match()</TT> will return 
a <TT class=class>MatchObject</TT>, so you should store the result in a variable 
for later use. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m = p.match( 'tempo')
&gt;&gt;&gt; print m
&lt;_sre.SRE_Match object at 80c4f68&gt;
</PRE></DIV>
<P>Now you can query the <TT class=class>MatchObject</TT> for information about 
the matching string. <TT class=class>MatchObject</TT> instances also have 
several methods and attributes; the most important ones are: 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Method/Attribute</B>&nbsp;</TH>
    <TH align=left><B>Purpose</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>group()</CODE></TD>
    <TD align=left>Return the string matched by the RE</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>start()</CODE></TD>
    <TD align=left>Return the starting position of the match</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>end()</CODE></TD>
    <TD align=left>Return the ending position of the match</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>span()</CODE></TD>
    <TD align=left>Return a tuple containing the (start, end) positions of the 
      match</TD></TR></TBODY></TABLE>
<P>Trying these methods will soon clarify their meaning: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m.group()
'tempo'
&gt;&gt;&gt; m.start(), m.end()
(0, 5)
&gt;&gt;&gt; m.span()
(0, 5)
</PRE></DIV>
<P><TT class=method>group()</TT> returns the substring that was matched by the 
RE. <TT class=method>start()</TT> and <TT class=method>end()</TT> return the 
starting and ending index of the match. <TT class=method>span()</TT> returns 
both start and end indexes in a single tuple. Since the <TT 
class=method>match</TT> method only checks if the RE matches at the start of a 
string, <TT class=method>start()</TT> will always be zero. However, the <TT 
class=method>search</TT> method of <TT class=class>RegexObject</TT> instances 
scans through the string, so the match may not start at zero in that case. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print p.match('::: message')
None
&gt;&gt;&gt; m = p.search('::: message') ; print m
&lt;re.MatchObject instance at 80c9650&gt;
&gt;&gt;&gt; m.group()
'message'
&gt;&gt;&gt; m.span()
(4, 11)
</PRE></DIV>
<P>In actual programs, the most common style is to store the <TT 
class=class>MatchObject</TT> in a variable, and then check if it was 
<CODE>None</CODE>. This usually looks like: 
<P>
<DIV class=verbatim><PRE>p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
    print 'Match found: ', m.group()
else:
    print 'No match'
</PRE></DIV>
<P>Two <TT class=class>RegexObject</TT> methods return all of the matches for a 
pattern. <TT class=method>findall()</TT> returns a list of matching strings: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']
</PRE></DIV>
<P><TT class=method>findall()</TT> has to create the entire list before it can 
be returned as the result. In Python 2.2, the <TT class=method>finditer()</TT> 
method is also available, returning a sequence of <TT 
class=class>MatchObject</TT> instances as an iterator. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
&gt;&gt;&gt; iterator
&lt;callable-iterator object at 0x401833ac&gt;
&gt;&gt;&gt; for match in iterator:
...     print match.span()
...
(0, 2)
(22, 24)
(29, 31)
</PRE></DIV>
<P>
<H2><A name=SECTION000440000000000000000>3.4 Module-Level Functions</A> </H2>
<P>You don't have to produce a <TT class=class>RegexObject</TT> and call its 
methods; the <TT class=module>re</TT> module also provides top-level functions 
called <TT class=function>match()</TT>, <TT class=function>search()</TT>, <TT 
class=function>sub()</TT>, and so forth. These functions take the same arguments 
as the corresponding <TT class=class>RegexObject</TT> method, with the RE string 
added as the first argument, and still return either <CODE>None</CODE> or a <TT 
class=class>MatchObject</TT> instance. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match(r'From\s+', 'Fromage amk')
None
&gt;&gt;&gt; re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')
&lt;re.MatchObject instance at 80c5978&gt;
</PRE></DIV>
<P>Under the hood, these functions simply produce a <TT 
class=class>RegexObject</TT> for you and call the appropriate method on it. They 
also store the compiled object in a cache, so future calls using the same RE are 
faster. 
<P>Should you use these module-level functions, or should you get the <TT 
class=class>RegexObject</TT> and call its methods yourself? That choice depends 
on how frequently the RE will be used, and on your personal coding style. If a 
RE is being used at only one point in the code, then the module functions are 
probably more convenient. If a program contains a lot of regular expressions, or 
re-uses the same ones in several locations, then it might be worthwhile to 
collect all the definitions in one place, in a section of code that compiles all 
the REs ahead of time. To take an example from the standard library, here's an 
extract from <SPAN class=file>xmllib.py</SPAN>: 
<P>
<DIV class=verbatim><PRE>ref = re.compile( ... )
entityref = re.compile( ... )
charref = re.compile( ... )
starttagopen = re.compile( ... )
</PRE></DIV>
<P>I generally prefer to work with the compiled object, even for one-time uses, 
but few people will be as much of a purist about this as I am. 
<P>
<H2><A name=SECTION000450000000000000000>3.5 Compilation Flags</A> </H2>
<P>Compilation flags let you modify some aspects of how regular expressions 
work. Flags are available in the <TT class=module>re</TT> module under two 
names, a long name such as <TT class=constant>IGNORECASE</TT>, and a short, 
one-letter form such as <TT class=constant>I</TT>. (If you're familiar with 
Perl's pattern modifiers, the one-letter forms use the same letters; the short 
form of <TT class=constant>re.VERBOSE</TT> is <TT class=constant>re.X</TT>, for 
example.) Multiple flags can be specified by bitwise OR-ing them; <CODE>re.I | 
re.M</CODE> sets both the <TT class=constant>I</TT> and <TT 
class=constant>M</TT> flags, for example. 
<P>Here's a table of the available flags, followed by a more detailed 
explanation of each one. 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Flag</B>&nbsp;</TH>
    <TH align=left><B>Meaning</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>DOTALL</TT>, <TT 
      class=constant>S</TT></TD>
    <TD align=left>Make <TT class=regexp>.</TT> match any character, including 
      newlines</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>IGNORECASE</TT>, <TT 
      class=constant>I</TT></TD>
    <TD align=left>Do case-insensitive matches</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>LOCALE</TT>, <TT 
      class=constant>L</TT></TD>
    <TD align=left>Do a locale-aware match</TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>MULTILINE</TT>, <TT 
      class=constant>M</TT></TD>
    <TD align=left>Multi-line matching, affecting <TT class=regexp>^</TT> and 
      <TT class=regexp>$</TT></TD>
  <TR>
    <TD vAlign=baseline align=middle><TT class=constant>VERBOSE</TT>, <TT 
      class=constant>X</TT></TD>
    <TD align=left>Enable verbose REs, which can be organized more cleanly and 
      understandably.</TD></TR></TBODY></TABLE>
<P>
<DL>
  <DT><B><A name=l2h-1><TT>I</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-6><TT>IGNORECASE</TT></A></B> 
  <DD>Perform case-insensitive matching; character class and literal strings 
  will match letters by ignoring case. For example, <TT class=regexp>[A-Z]</TT> 
  will match lowercase letters, too, and <TT class=regexp>Spam</TT> will match 
  "<TT class=samp>Spam</TT>", "<TT class=samp>spam</TT>", or "<TT 
  class=samp>spAM</TT>". This lowercasing doesn't take the current locale into 
  account; it will if you also set the <TT class=constant>LOCALE</TT> flag. 
</DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-2><TT>L</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-7><TT>LOCALE</TT></A></B> 
  <DD>Make <TT class=regexp>\w</TT>, <TT class=regexp>\W</TT>, <TT 
  class=regexp>\b</TT>, and <TT class=regexp>\B</TT>, dependent on the current 
  locale. 
  <P>Locales are a feature of the C library intended to help in writing programs 
  that take account of language differences. For example, if you're processing 
  French text, you'd want to be able to write <TT class=regexp>\w+</TT> to match 
  words, but <TT class=regexp>\w</TT> only matches the character class <TT 
  class=regexp>[A-Za-z]</TT>; it won't match "<TT class=character>e</TT>" or 
  "<TT class=character>c</TT>". If your system is configured properly and a 
  French locale is selected, certain C functions will tell the program that "<TT 
  class=character>e</TT>" should also be considered a letter. Setting the <TT 
  class=constant>LOCALE</TT> flag when compiling a regular expression will cause 
  the resulting compiled object to use these C functions for <TT 
  class=regexp>\w</TT>; this is slower, but also enables <TT 
  class=regexp>\w+</TT> to match French words as you'd expect. </P></DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-3><TT>M</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-8><TT>MULTILINE</TT></A></B> 
  <DD>(<TT class=regexp>^</TT> and <TT class=regexp>$</TT> haven't been 
  explained yet; they'll be introduced in section&nbsp;<A 
  href="regex.html#more-metacharacters"><U><FONT 
  color=#0000ff>4.1</FONT></U></A>.) 
  <P>Usually <TT class=regexp>^</TT> matches only at the beginning of the 
  string, and <TT class=regexp>$</TT> matches only at the end of the string and 
  immediately before the newline (if any) at the end of the string. When this 
  flag is specified, <TT class=regexp>^</TT> matches at the beginning of the 
  string and at the beginning of each line within the string, immediately 
  following each newline. Similarly, the <TT class=regexp>$</TT> metacharacter 
  matches either at the end of the string and at the end of each line 
  (immediately preceding each newline). 
  <P></P></DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-4><TT>S</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-9><TT>DOTALL</TT></A></B> 
  <DD>Makes the "<TT class=character>.</TT>" special character match any 
  character at all, including a newline; without this flag, "<TT 
  class=character>.</TT>" will match anything <I>except</I> a newline. </DD></DL>
<P>
<DL>
  <DT><B><A name=l2h-5><TT>X</TT></A></B> 
  <DD>
  <DT><B><A name=l2h-10><TT>VERBOSE</TT></A></B> 
  <DD>This flag allows you to write regular expressions that are more readable 
  by granting you more flexibility in how you can format them. When this flag 
  has been specified, whitespace within the RE string is ignored, except when 
  the whitespace is in a character class or preceded by an unescaped backslash; 
  this lets you organize and indent the RE more clearly. It also enables you to 
  put comments within a RE that will be ignored by the engine; comments are 
  marked by a "<TT class=character>#</TT>" that's neither in a character class 
  or preceded by an unescaped backslash. 
  <P>For example, here's a RE that uses <TT class=constant>re.VERBOSE</TT>; see 
  how much easier it is to read? 
  <P>
  <DIV class=verbatim><PRE>charref = re.compile(r"""
 &amp;[#]		     # Start of a numeric entity reference
 (
   [0-9]+[^0-9]      # Decimal form
   | 0[0-7]+[^0-7]   # Octal form
   | x[0-9a-fA-F]+[^0-9a-fA-F] # Hexadecimal form
 )
""", re.VERBOSE)
</PRE></DIV>
  <P>Without the verbose setting, the RE would look like this: 
  <DIV class=verbatim><PRE>charref = re.compile("&amp;#([0-9]+[^0-9]"
                     "|0[0-7]+[^0-7]"
                     "|x[0-9a-fA-F]+[^0-9a-fA-F])")
</PRE></DIV>
  <P>In the above example, Python's automatic concatenation of string literals 
  has been used to break up the RE into smaller pieces, but it's still more 
  difficult to understand than the version using <TT 
  class=constant>re.VERBOSE</TT>. 
  <P></P></DD></DL>
<P>
<H1><A name=SECTION000500000000000000000>4 More Pattern Power</A> </H1>
<P>So far we've only covered a part of the features of regular expressions. In 
this section, we'll cover some new metacharacters, and how to use groups to 
retrieve portions of the text that was matched. 
<P>
<H2><A name=SECTION000510000000000000000></A> <BR>4.1 More Metacharacters </H2>
<P>There are some metacharacters that we haven't covered yet. Most of them will 
be covered in this section. 
<P>Some of the remaining metacharacters to be discussed are <I 
class=dfn>zero-width assertions</I>. They don't cause the engine to advance 
through the string; instead, they consume no characters at all, and simply 
succeed or fail. For example, <TT class=regexp>\b</TT> is an assertion that the 
current position is located at a word boundary; the position isn't changed by 
the <TT class=regexp>\b</TT> at all. This means that zero-width assertions 
should never be repeated, because if they match once at a given location, they 
can obviously be matched an infinite number of times. 
<P>
<DL compact>
  <DT><TT class=regexp>|</TT> 
  <DD>Alternation, or the ``or'' operator. If A and B are regular expressions, 
  <TT class=regexp>A|B</TT> will match any string that matches either "<TT 
  class=samp>A</TT>" or "<TT class=samp>B</TT>". <TT class=regexp>|</TT> has 
  very low precedence in order to make it work reasonably when you're 
  alternating multi-character strings. <TT class=regexp>Crow|Servo</TT> will 
  match either "<TT class=samp>Crow</TT>" or "<TT class=samp>Servo</TT>", not 
  "<TT class=samp>Cro</TT>", a "<TT class=character>w</TT>" or an "<TT 
  class=character>S</TT>", and "<TT class=samp>ervo</TT>". 
  <P>To match a literal "<TT class=character>|</TT>", use <TT 
  class=regexp>\|</TT>, or enclose it inside a character class, as in <TT 
  class=regexp>[|]</TT>. 
  <P></P>
  <DT><TT class=regexp>^</TT> 
  <DD>Matches at the beginning of lines. Unless the <TT 
  class=constant>MULTILINE</TT> flag has been set, this will only match at the 
  beginning of the string. In <TT class=constant>MULTILINE</TT> mode, this also 
  matches immediately after each newline within the string. 
  <P>For example, if you wish to match the word "<TT class=samp>From</TT>" only 
  at the beginning of a line, the RE to use is <CODE>^From</CODE>. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('^From', 'From Here to Eternity')
&lt;re.MatchObject instance at 80c1520&gt;
&gt;&gt;&gt; print re.search('^From', 'Reciting From Memory')
None
</PRE></DIV>
  <P></P>
  <DT><TT class=regexp>$</TT> 
  <DD>Matches at the end of a line, which is defined as either the end of the 
  string, or any location followed by a newline character. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('}$', '{block}')
&lt;re.MatchObject instance at 80adfa8&gt;
&gt;&gt;&gt; print re.search('}$', '{block} ')
None
&gt;&gt;&gt; print re.search('}$', '{block}\n')
&lt;re.MatchObject instance at 80adfa8&gt;
</PRE></DIV>
  <P>To match a literal "<TT class=character>$</TT>", use <TT 
  class=regexp>\$</TT> or enclose it inside a character class, as in <TT 
  class=regexp>[$]</TT>. 
  <P></P>
  <DT><TT class=regexp>\A</TT> 
  <DD>Matches only at the start of the string. When not in <TT 
  class=constant>MULTILINE</TT> mode, <TT class=regexp>\A</TT> and <TT 
  class=regexp>^</TT> are effectively the same. In <TT 
  class=constant>MULTILINE</TT> mode, however, they're different; <TT 
  class=regexp>\A</TT> still matches only at the beginning of the string, but 
  <TT class=regexp>^</TT> may match at any location inside the string that 
  follows a newline character. 
  <P></P>
  <DT><TT class=regexp>\Z</TT> 
  <DD>Matches only at the end of the string. 
  <P></P>
  <DT><TT class=regexp>\b</TT> 
  <DD>Word boundary. This is a zero-width assertion that matches only at the 
  beginning or end of a word. A word is defined as a sequence of alphanumeric 
  characters, so the end of a word is indicated by whitespace or a 
  non-alphanumeric character. 
  <P>The following example matches "<TT class=samp>class</TT>" only when it's a 
  complete word; it won't match when it's contained inside another word. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\bclass\b')
&gt;&gt;&gt; print p.search('no class at all')
&lt;re.MatchObject instance at 80c8f28&gt;
&gt;&gt;&gt; print p.search('the declassified algorithm')
None
&gt;&gt;&gt; print p.search('one subclass is')
None
</PRE></DIV>
  <P>There are two subtleties you should remember when using this special 
  sequence. First, this is the worst collision between Python's string literals 
  and regular expression sequences. In Python's string literals, "<TT 
  class=samp>\b</TT>" is the backspace character, ASCII value 8. If you're not 
  using raw strings, then Python will convert the "<TT class=samp>\b</TT>" to a 
  backspace, and your RE won't match as you expect it to. The following example 
  looks the same as our previous RE, but omits the "<TT class=character>r</TT>" 
  in front of the RE string. 
  <P>
  <DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('\bclass\b')
&gt;&gt;&gt; print p.search('no class at all')
None
&gt;&gt;&gt; print p.search('\b' + 'class' + '\b')  
&lt;re.MatchObject instance at 80c3ee0&gt;
</PRE></DIV>
  <P>Second, inside a character class, where there's no use for this assertion, 
  <TT class=regexp>\b</TT> represents the backspace character, for compatibility 
  with Python's string literals. 
  <P></P>
  <DT><TT class=regexp>\B</TT> 
  <DD>Another zero-width assertion, this is the opposite of <TT 
  class=regexp>\b</TT>, only matching when the current position is not at a word 
  boundary. 
  <P></P></DD></DL>
<P>
<H2><A name=SECTION000520000000000000000>4.2 Grouping</A> </H2>
<P>Frequently you need to obtain more information than just whether the RE 
matched or not. Regular expressions are often used to dissect strings by writing 
a RE divided into several subgroups which match different components of 
interest. For example, an RFC-822 header line is divided into a header name and 
a value, separated by a "<TT class=character>:</TT>". This can be handled by 
writing a regular expression which matches an entire header line, and has one 
group which matches the header name, and another group which matches the 
header's value. 
<P>Groups are marked by the "<TT class=character>(</TT>", "<TT 
class=character>)</TT>" metacharacters. "<TT class=character>(</TT>" and "<TT 
class=character>)</TT>" have much the same meaning as they do in mathematical 
expressions; they group together the expressions contained inside them. For 
example, you can repeat the contents of a group with a repeating qualifier, such 
as <TT class=regexp>*</TT>, <TT class=regexp>+</TT>, <TT class=regexp>?</TT>, or 
<TT class=regexp>{<VAR>m</VAR>,<VAR>n</VAR>}</TT>. For example, <TT 
class=regexp>(ab)*</TT> will match zero or more repetitions of "<TT 
class=samp>ab</TT>". 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(ab)*')
&gt;&gt;&gt; print p.match('ababababab').span()
(0, 10)
</PRE></DIV>
<P>Groups indicated with "<TT class=character>(</TT>", "<TT 
class=character>)</TT>" also capture the starting and ending index of the text 
that they match; this can be retrieved by passing an argument to <TT 
class=method>group()</TT>, <TT class=method>start()</TT>, <TT 
class=method>end()</TT>, and <TT class=method>span()</TT>. Groups are numbered 
starting with 0. Group 0 is always present; it's the whole RE, so <TT 
class=class>MatchObject</TT> methods all have group 0 as their default argument. 
Later we'll see how to express groups that don't capture the span of text that 
they match. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(a)b')
&gt;&gt;&gt; m = p.match('ab')
&gt;&gt;&gt; m.group()
'ab'
&gt;&gt;&gt; m.group(0)
'ab'
</PRE></DIV>
<P>Subgroups are numbered from left to right, from 1 upward. Groups can be 
nested; to determine the number, just count the opening parenthesis characters, 
going from left to right. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('(a(b)c)d')
&gt;&gt;&gt; m = p.match('abcd')
&gt;&gt;&gt; m.group(0)
'abcd'
&gt;&gt;&gt; m.group(1)
'abc'
&gt;&gt;&gt; m.group(2)
'b'
</PRE></DIV>
<P><TT class=method>group()</TT> can be passed multiple group numbers at a time, 
in which case it will return a tuple containing the corresponding values for 
those groups. 
<P>
<DIV class=verbatim><PRE>  
&gt;&gt;&gt; m.group(2,1,2)
('b', 'abc', 'b')
</PRE></DIV>
<P>The <TT class=method>groups()</TT> method returns a tuple containing the 
strings for all the subgroups, from 1 up to however many there are. 
<P>
<DIV class=verbatim><PRE>  
&gt;&gt;&gt; m.groups()
('abc', 'b')
</PRE></DIV>
<P>Backreferences in a pattern allow you to specify that the contents of an 
earlier capturing group must also be found at the current location in the 
string. For example, <TT class=regexp>\1</TT> will succeed if the exact contents 
of group 1 can be found at the current position, and fails otherwise. Remember 
that Python's string literals also use a backslash followed by numbers to allow 
including arbitrary characters in a string, so be sure to use a raw string when 
incorporating backreferences in a RE. 
<P>For example, the following RE detects doubled words in a string. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(\b\w+)\s+\1')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</PRE></DIV>
<P>Backreferences like this aren't often useful for just searching through a 
string -- there are few text formats which repeat data in this way -- but you'll 
soon find out that they're <I>very</I> useful when performing string 
substitutions. 
<P>
<H2><A name=SECTION000530000000000000000>4.3 Non-capturing and Named Groups</A> 
</H2>
<P>Elaborate REs may use many groups, both to capture substrings of interest, 
and to group and structure the RE itself. In complex REs, it becomes difficult 
to keep track of the group numbers. There are two features which help with this 
problem. Both of them use a common syntax for regular expression extensions, so 
we'll look at that first. 
<P>Perl 5 added several additional features to standard regular expressions, and 
the Python <TT class=module>re</TT> module supports most of them. It would have 
been difficult to choose new single-keystroke metacharacters or new special 
sequences beginning with "<TT class=samp>\</TT>" to represent the new features 
without making Perl's regular expressions confusingly different from standard 
REs. If you chose "<TT class=samp>&amp;</TT>" as a new metacharacter, for 
example, old expressions would be assuming that "<TT class=samp>&amp;</TT>" was 
a regular character and wouldn't have escaped it by writing <TT 
class=regexp>\&amp;</TT> or <TT class=regexp>[&amp;]</TT>. 
<P>The solution chosen by the Perl developers was to use <TT 
class=regexp>(?...)</TT> as the extension syntax. "<TT class=samp>?</TT>" 
immediately after a parenthesis was a syntax error because the "<TT 
class=samp>?</TT>" would have nothing to repeat, so this didn't introduce any 
compatibility problems. The characters immediately after the "<TT 
class=samp>?</TT>" indicate what extension is being used, so <TT 
class=regexp>(?=foo)</TT> is one thing (a positive lookahead assertion) and <TT 
class=regexp>(?:foo)</TT> is something else (a non-capturing group containing 
the subexpression <TT class=regexp>foo</TT>). 
<P>Python adds an extension syntax to Perl's extension syntax. If the first 
character after the question mark is a "<TT class=samp>P</TT>", you know that 
it's an extension that's specific to Python. Currently there are two such 
extensions: <TT class=regexp>(?P&lt;<VAR>name</VAR>&gt;...)</TT> defines a named 
group, and <TT class=regexp>(?P=<VAR>name</VAR>)</TT> is a backreference to a 
named group. If future versions of Perl 5 add similar features using a different 
syntax, the <TT class=module>re</TT> module will be changed to support the new 
syntax, while preserving the Python-specific syntax for compatibility's sake. 
<P>Now that we've looked at the general extension syntax, we can return to the 
features that simplify working with groups in complex REs. Since groups are 
numbered from left to right and a complex expression may use many groups, it can 
become difficult to keep track of the correct numbering, and modifying such a 
complex RE is annoying. Insert a new group near the beginning, and you change 
the numbers of everything that follows it. 
<P>First, sometimes you'll want to use a group to collect a part of a regular 
expression, but aren't interested in retrieving the group's contents. You can 
make this fact explicit by using a non-capturing group: <TT 
class=regexp>(?:...)</TT>, where you can put any other regular expression inside 
the parentheses. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; m = re.match("([abc])+", "abc")
&gt;&gt;&gt; m.groups()
('c',)
&gt;&gt;&gt; m = re.match("(?:[abc])+", "abc")
&gt;&gt;&gt; m.groups()
()
</PRE></DIV>
<P>Except for the fact that you can't retrieve the contents of what the group 
matched, a non-capturing group behaves exactly the same as a capturing group; 
you can put anything inside it, repeat it with a repetition metacharacter such 
as "<TT class=samp>*</TT>", and nest it within other groups (capturing or 
non-capturing). <TT class=regexp>(?:...)</TT> is particularly useful when 
modifying an existing group, since you can add new groups without changing how 
all the other groups are numbered. It should be mentioned that there's no 
performance difference in searching between capturing and non-capturing groups; 
neither form is any faster than the other. 
<P>The second, and more significant, feature is named groups; instead of 
referring to them by numbers, groups can be referenced by a name. 
<P>The syntax for a named group is one of the Python-specific extensions: <TT 
class=regexp>(?P&lt;<VAR>name</VAR>&gt;...)</TT>. <VAR>name</VAR> is, obviously, 
the name of the group. Except for associating a name with a group, named groups 
also behave identically to capturing groups. The <TT 
class=class>MatchObject</TT> methods that deal with capturing groups all accept 
either integers, to refer to groups by number, or a string containing the group 
name. Named groups are still given numbers, so you can retrieve information 
about a group in two ways: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+\b)')
&gt;&gt;&gt; m = p.search( '(((( Lots of punctuation )))' )
&gt;&gt;&gt; m.group('word')
'Lots'
&gt;&gt;&gt; m.group(1)
'Lots'
</PRE></DIV>
<P>Named groups are handy because they let you use easily-remembered names, 
instead of having to remember numbers. Here's an example RE from the <TT 
class=module>imaplib</TT> module: 
<P>
<DIV class=verbatim><PRE>InternalDate = re.compile(r'INTERNALDATE "'
        r'(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-'
	r'(?P&lt;year&gt;[0-9][0-9][0-9][0-9])'
        r' (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])'
        r' (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])'
        r'"')
</PRE></DIV>
<P>It's obviously much easier to retrieve <CODE>m.group('zonem')</CODE>, instead 
of having to remember to retrieve group 9. 
<P>Since the syntax for backreferences, in an expression like <TT 
class=regexp>(...)\1</TT>, refers to the number of the group there's naturally a 
variant that uses the group name instead of the number. This is also a Python 
extension: <TT class=regexp>(?P=<VAR>name</VAR>)</TT> indicates that the 
contents of the group called <VAR>name</VAR> should again be found at the 
current point. The regular expression for finding doubled words, <TT 
class=regexp>(\b\w+)\s+\1</TT> can also be written as <TT 
class=regexp>(?P&lt;word&gt;\b\w+)\s+(?P=word)</TT>: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+)\s+(?P=word)')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</PRE></DIV>
<P>
<H2><A name=SECTION000540000000000000000>4.4 Lookahead Assertions</A> </H2>
<P>Another zero-width assertion is the lookahead assertion. Lookahead assertions 
are available in both positive and negative form, and look like this: 
<P>
<DL compact>
  <DT><TT class=regexp>(?=...)</TT> 
  <DD>Positive lookahead assertion. This succeeds if the contained regular 
  expression, represented here by <CODE>...</CODE>, successfully matches at the 
  current location, and fails otherwise. But, once the contained expression has 
  been tried, the matching engine doesn't advance at all; the rest of the 
  pattern is tried right where the assertion started. 
  <P></P>
  <DT><TT class=regexp>(?!...)</TT> 
  <DD>Negative lookahead assertion. This is the opposite of the positive 
  assertion; it succeeds if the contained expression <I>doesn't</I> match at the 
  current position in the string. </DD></DL>
<P>An example will help make this concrete by demonstrating a case where a 
lookahead is useful. Consider a simple pattern to match a filename and split it 
apart into a base name and an extension, separated by a "<TT class=samp>.</TT>". 
For example, in "<TT class=samp>news.rc</TT>", "<TT class=samp>news</TT>"is the 
base name, and "<TT class=samp>rc</TT>" is the filename's extension. 
<P>The pattern to match this is quite simple: 
<P><TT class=regexp>.*[.].*$</TT> 
<P>Notice that the "<TT class=samp>.</TT>" needs to be treated specially because 
it's a metacharacter; I've put it inside a character class. Also notice the 
trailing <TT class=regexp>$</TT>; this is added to ensure that all the rest of 
the string must be included in the extension. This regular expression matches 
"<TT class=samp>foo.bar</TT>" and "<TT class=samp>autoexec.bat</TT>" and "<TT 
class=samp>sendmail.cf</TT>" and "<TT class=samp>printers.conf</TT>". 
<P>Now, consider complicating the problem a bit; what if you want to match 
filenames where the extension is not "<TT class=samp>bat</TT>"? Some incorrect 
attempts: 
<P><CODE>.*[.][^b].*$</CODE> 
<P>The first attempt above tries to exclude "<TT class=samp>bat</TT>" by 
requiring that the first character of the extension is not a "<TT 
class=samp>b</TT>". This is wrong, because the pattern also doesn't match "<TT 
class=samp>foo.bar</TT>". 
<P><TT class=regexp>.*[.]([^b]..|.[^a].|..[^t])$</TT> 
<P>The expression gets messier when you try to patch up the first solution by 
requiring one of the following cases to match: the first character of the 
extension isn't "<TT class=samp>b</TT>"; the second character isn't "<TT 
class=samp>a</TT>"; or the third character isn't "<TT class=samp>t</TT>". This 
accepts "<TT class=samp>foo.bar</TT>" and rejects "<TT 
class=samp>autoexec.bat</TT>", but it requires a three-letter extension and 
won't accept a filename with a two-letter extension such as "<TT 
class=samp>sendmail.cf</TT>". We'll complicate the pattern again in an effort to 
fix it. 
<P><TT class=regexp>.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</TT> 
<P>In the third attempt, the second and third letters are all made optional in 
order to allow matching extensions shorter than three characters, such as "<TT 
class=samp>sendmail.cf</TT>". 
<P>The pattern's getting really complicated now, which makes it hard to read and 
understand. Worse, if the problem changes and you want to exclude both "<TT 
class=samp>bat</TT>" and "<TT class=samp>exe</TT>" as extensions, the pattern 
would get even more complicated and confusing. 
<P>A negative lookahead cuts through all this: 
<P><TT class=regexp>.*[.](?!bat$).*$</TT> 
<P>The lookahead means: if the expression <TT class=regexp>bat</TT> doesn't 
match at this point, try the rest of the pattern; if <TT class=regexp>bat$</TT> 
does match, the whole pattern will fail. The trailing <TT class=regexp>$</TT> is 
required to ensure that something like "<TT class=samp>sample.batch</TT>", where 
the extension only starts with "<TT class=samp>bat</TT>", will be allowed. 
<P>Excluding another filename extension is now easy; simply add it as an 
alternative inside the assertion. The following pattern excludes filenames that 
end in either "<TT class=samp>bat</TT>" or "<TT class=samp>exe</TT>": 
<P><TT class=regexp>.*[.](?!bat$|exe$).*$</TT> 
<P>
<H1><A name=SECTION000600000000000000000>5 Modifying Strings</A> </H1>
<P>Up to this point, we've simply performed searches against a static string. 
Regular expressions are also commonly used to modify a string in various ways, 
using the following <TT class=class>RegexObject</TT> methods: 
<P>
<TABLE style="BORDER-COLLAPSE: collapse" align=center border=1>
  <THEAD>
  <TR class=tableheader>
    <TH align=middle><B>Method/Attribute</B>&nbsp;</TH>
    <TH align=left><B>Purpose</B>&nbsp;</TH></TR></THEAD>
  <TBODY vAlign=baseline>
  <TR>
    <TD vAlign=baseline align=middle><CODE>split()</CODE></TD>
    <TD align=left>Split the string into a list, splitting it wherever the RE 
      matches</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>sub()</CODE></TD>
    <TD align=left>Find all substrings where the RE matches, and replace them 
      with a different string</TD>
  <TR>
    <TD vAlign=baseline align=middle><CODE>subn()</CODE></TD>
    <TD align=left>Does the same thing as <TT class=method>sub()</TT>, but 
      returns the new string and the number of replacements</TD></TR></TBODY></TABLE>
<P>
<H2><A name=SECTION000610000000000000000>5.1 Splitting Strings</A> </H2>
<P>The <TT class=method>split()</TT> method of a <TT 
class=class>RegexObject</TT> splits a string apart wherever the RE matches, 
returning a list of the pieces. It's similar to the <TT 
class=method>split()</TT> method of strings but provides much more generality in 
the delimiters that you can split by; <TT class=method>split()</TT> only 
supports splitting by whitespace or by a fixed string. As you'd expect, there's 
a module-level <TT class=function>re.split()</TT> function, too. 
<P>
<DL>
  <DT>
  <TABLE cellSpacing=0 cellPadding=0>
    
    <TR vAlign=baseline>
      <TD><NOBR><B><A name=l2h-11><TT 
      class=method>split</TT></A></B>(</NOBR></TD>
      <TD><VAR>string </VAR><BIG><FONT size=4>[</FONT></BIG><VAR>, 
        maxsplit<CODE> = 0</CODE></VAR><BIG><FONT 
    size=4>]</FONT></BIG>)</TD></TR></TABLE>
  <DD>Split <VAR>string</VAR> by the matches of the regular expression. If 
  capturing parentheses are used in the RE, then their contents will also be 
  returned as part of the resulting list. If <VAR>maxsplit</VAR> is nonzero, at 
  most <VAR>maxsplit</VAR> splits are performed. </DD></DL>
<P>You can limit the number of splits made, by passing a value for 
<VAR>maxsplit</VAR>. When <VAR>maxsplit</VAR> is nonzero, at most 
<VAR>maxsplit</VAR> splits will be made, and the remainder of the string is 
returned as the final element of the list. In the following example, the 
delimiter is any sequence of non-alphanumeric characters. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
</PRE></DIV>
<P>Sometimes you're not only interested in what the text between delimiters is, 
but also need to know what the delimiter was. If capturing parentheses are used 
in the RE, then their values are also returned as part of the list. Compare the 
following calls: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p2 = re.compile(r'(\W+)')
&gt;&gt;&gt; p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
&gt;&gt;&gt; p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
</PRE></DIV>
<P>The module-level function <TT class=function>re.split()</TT> adds the RE to 
be used as the first argument, but is otherwise the same. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; re.split('[\W]+', 'Words, words, words.')
['Words', 'words', 'words', '']
&gt;&gt;&gt; re.split('([\W]+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
&gt;&gt;&gt; re.split('[\W]+', 'Words, words, words.', 1)
['Words', 'words, words.']
</PRE></DIV>
<P>
<H2><A name=SECTION000620000000000000000>5.2 Search and Replace</A> </H2>
<P>Another common task is to find all the matches for a pattern, and replace 
them with a different string. The <TT class=method>sub()</TT> method takes a 
replacement value, which can be either a string or a function, and the string to 
be processed. 
<P>
<DL>
  <DT>
  <TABLE cellSpacing=0 cellPadding=0>
    
    <TR vAlign=baseline>
      <TD><NOBR><B><A name=l2h-12><TT class=method>sub</TT></A></B>(</NOBR></TD>
      <TD><VAR>replacement, string</VAR><BIG><FONT size=4>[</FONT></BIG><VAR>, 
        count<CODE> = 0</CODE></VAR><BIG><FONT 
    size=4>]</FONT></BIG>)</TD></TR></TABLE>
  <DD>Returns the string obtained by replacing the leftmost non-overlapping 
  occurrences of the RE in <VAR>string</VAR> by the replacement 
  <VAR>replacement</VAR>. If the pattern isn't found, <VAR>string</VAR> is 
  returned unchanged. 
  <P>The optional argument <VAR>count</VAR> is the maximum number of pattern 
  occurrences to be replaced; <VAR>count</VAR> must be a non-negative integer. 
  The default value of 0 means to replace all occurrences. </P></DD></DL>
<P>Here's a simple example of using the <TT class=method>sub()</TT> method. It 
replaces colour names with the word "<TT class=samp>colour</TT>": 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile( '(blue|white|red)')
&gt;&gt;&gt; p.sub( 'colour', 'blue socks and red shoes')
'colour socks and colour shoes'
&gt;&gt;&gt; p.sub( 'colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'
</PRE></DIV>
<P>The <TT class=method>subn()</TT> method does the same work, but returns a 
2-tuple containing the new string value and the number of replacements that were 
performed: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile( '(blue|white|red)')
&gt;&gt;&gt; p.subn( 'colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
&gt;&gt;&gt; p.subn( 'colour', 'no colours at all')
('no colours at all', 0)
</PRE></DIV>
<P>Empty matches are replaced only when they're not adjacent to a previous 
match. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('x*')
&gt;&gt;&gt; p.sub('-', 'abxd')
'-a-b-d-'
</PRE></DIV>
<P>If <VAR>replacement</VAR> is a string, any backslash escapes in it are 
processed. That is, "<TT class=samp>\n</TT>" is converted to a single newline 
character, "<TT class=samp>\r</TT>" is converted to a carriage return, and so 
forth. Unknown escapes such as "<TT class=samp>\j</TT>" are left alone. 
Backreferences, such as "<TT class=samp>\6</TT>", are replaced with the 
substring matched by the corresponding group in the RE. This lets you 
incorporate portions of the original text in the resulting replacement string. 
<P>This example matches the word "<TT class=samp>section</TT>" followed by a 
string enclosed in "<TT class=samp>{</TT>", "<TT class=samp>}</TT>", and changes 
"<TT class=samp>section</TT>" to "<TT class=samp>subsection</TT>": 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First} section{second}')
'subsection{First} subsection{second}'
</PRE></DIV>
<P>There's also a syntax for referring to named groups as defined by the <TT 
class=regexp>(?P&lt;name&gt;...)</TT> syntax. "<TT 
class=samp>\g&lt;name&gt;</TT>" will use the substring matched by the group 
named "<TT class=samp>name</TT>", and "<TT 
class=samp>\g&lt;<VAR>number</VAR>&gt;</TT>" uses the corresponding group 
number. "<TT class=samp>\g&lt;2&gt;</TT>" is therefore equivalent to "<TT 
class=samp>\2</TT>", but isn't ambiguous in a replacement string such as "<TT 
class=samp>\g&lt;2&gt;0</TT>". ("<TT class=samp>\20</TT>" would be interpreted 
as a reference to group 20, not a reference to group 2 followed by the literal 
character "<TT class=character>0</TT>".) The following substitutions are all 
equivalent, but use all three variations of the replacement string. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; p = re.compile('section{ (?P&lt;name&gt; [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;1&gt;}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;name&gt;}','section{First}')
'subsection{First}'
</PRE></DIV>
<P><VAR>replacement</VAR> can also be a function, which gives you even more 
control. If <VAR>replacement</VAR> is a function, the function is called for 
every non-overlapping occurrence of <VAR>pattern</VAR>. On each call, the 
function is passed a <TT class=class>MatchObject</TT> argument for the match and 
can use this information to compute the desired replacement string and return 
it. 
<P>In the following example, the replacement function translates decimals into 
hexadecimal: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; def hexrepl( match ):
...     "Return the hex string for a decimal number"
...     value = int( match.group() )
...     return hex(value)
...
&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
</PRE></DIV>
<P>When using the module-level <TT class=function>re.sub()</TT> function, the 
pattern is passed as the first argument. The pattern may be a string or a <TT 
class=class>RegexObject</TT>; if you need to specify regular expression flags, 
you must either use a <TT class=class>RegexObject</TT> as the first parameter, 
or use embedded modifiers in the pattern, e.g. <CODE>sub("(?i)b+", "x", "bbbb 
BBBB")</CODE> returns <CODE>'x x'</CODE>. 
<P>
<H1><A name=SECTION000700000000000000000>6 Common Problems</A> </H1>
<P>Regular expressions are a powerful tool for some applications, but in some 
ways their behaviour isn't intuitive and at times they don't behave the way you 
may expect them to. This section will point out some of the most common 
pitfalls. 
<P>
<H2><A name=SECTION000710000000000000000>6.1 Use String Methods</A> </H2>
<P>Sometimes using the <TT class=module>re</TT> module is a mistake. If you're 
matching a fixed string, or a single character class, and you're not using any 
<TT class=module>re</TT> features such as the <TT class=constant>IGNORECASE</TT> 
flag, then the full power of regular expressions may not be required. Strings 
have several methods for performing operations with fixed strings and they're 
usually much faster, because the implementation is a single small C loop that's 
been optimized for the purpose, instead of the large, more generalized regular 
expression engine. 
<P>One example might be replacing a single fixed string with another one; for 
example, you might replace "<TT class=samp>word</TT>"with "<TT 
class=samp>deed</TT>". <CODE>re.sub()</CODE> seems like the function to use for 
this, but consider the <TT class=method>replace()</TT> method. Note that <TT 
class=function>replace()</TT> will also replace "<TT class=samp>word</TT>" 
inside words, turning "<TT class=samp>swordfish</TT>" into "<TT 
class=samp>sdeedfish</TT>", but the naive RE <TT class=regexp>word</TT> would 
have done that, too. (To avoid performing the substitution on parts of words, 
the pattern would have to be <TT class=regexp>\bword\b</TT>, in order to require 
that "<TT class=samp>word</TT>" have a word boundary on either side. This takes 
the job beyond <TT class=method>replace</TT>'s abilities.) 
<P>Another common task is deleting every occurrence of a single character from a 
string or replacing it with another single character. You might do this with 
something like <CODE>re.sub('\n', ' ', S)</CODE>, but <TT 
class=method>translate()</TT> is capable of doing both tasks and will be faster 
that any regular expression operation can be. 
<P>In short, before turning to the <TT class=module>re</TT> module, consider 
whether your problem can be solved with a faster and simpler string method. 
<P>
<H2><A name=SECTION000720000000000000000>6.2 match() versus search()</A> </H2>
<P>The <TT class=function>match()</TT> function only checks if the RE matches at 
the beginning of the string while <TT class=function>search()</TT> will scan 
forward through the string for a match. It's important to keep this distinction 
in mind. Remember, <TT class=function>match()</TT> will only report a successful 
match which will start at 0; if the match wouldn't start at zero, <TT 
class=function>match()</TT> will <I>not</I> report it. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match('super', 'superstition').span()  
(0, 5)
&gt;&gt;&gt; print re.match('super', 'insuperable')    
None
</PRE></DIV>
<P>On the other hand, <TT class=function>search()</TT> will scan forward through 
the string, reporting the first match it finds. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.search('super', 'superstition').span()
(0, 5)
&gt;&gt;&gt; print re.search('super', 'insuperable').span()
(2, 7)
</PRE></DIV>
<P>Sometimes you'll be tempted to keep using <TT class=function>re.match()</TT>, 
and just add <TT class=regexp>.*</TT> to the front of your RE. Resist this 
temptation and use <TT class=function>re.search()</TT> instead. The regular 
expression compiler does some analysis of REs in order to speed up the process 
of looking for a match. One such analysis figures out what the first character 
of a match must be; for example, a pattern starting with <TT 
class=regexp>Crow</TT> must match starting with a "<TT class=character>C</TT>". 
The analysis lets the engine quickly scan through the string looking for the 
starting character, only trying the full match if a "<TT class=character>C</TT>" 
is found. 
<P>Adding <TT class=regexp>.*</TT> defeats this optimization, requiring scanning 
to the end of the string and then backtracking to find a match for the rest of 
the RE. Use <TT class=function>re.search()</TT> instead. 
<P>
<H2><A name=SECTION000730000000000000000>6.3 Greedy versus Non-Greedy</A> </H2>
<P>When repeating a regular expression, as in <TT class=regexp>a*</TT>, the 
resulting action is to consume as much of the pattern as possible. This fact 
often bites you when you're trying to match a pair of balanced delimiters, such 
as the angle brackets surrounding an HTML tag. The naive pattern for matching a 
single HTML tag doesn't work because of the greedy nature of <TT 
class=regexp>.*</TT>. 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; s = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'
&gt;&gt;&gt; len(s)
32
&gt;&gt;&gt; print re.match('&lt;.*&gt;', s).span()
(0, 32)
&gt;&gt;&gt; print re.match('&lt;.*&gt;', s).group()
&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;
</PRE></DIV>
<P>The RE matches the "<TT class=character>&lt;</TT>" in "<TT 
class=samp>&lt;html&gt;</TT>", and the <TT class=regexp>.*</TT> consumes the 
rest of the string. There's still more left in the RE, though, and the <TT 
class=regexp>&gt;</TT> can't match at the end of the string, so the regular 
expression engine has to backtrack character by character until it finds a match 
for the <TT class=regexp>&gt;</TT>. The final match extends from the "<TT 
class=character>&lt;</TT>" in "<TT class=samp>&lt;html&gt;</TT>"to the "<TT 
class=character>&gt;</TT>" in "<TT class=samp>&lt;/title&gt;</TT>", which isn't 
what you want. 
<P>In this case, the solution is to use the non-greedy qualifiers <TT 
class=regexp>*?</TT>, <TT class=regexp>+?</TT>, <TT class=regexp>??</TT>, or <TT 
class=regexp>{<VAR>m</VAR>,<VAR>n</VAR>}?</TT>, which match as <I>little</I> 
text as possible. In the above example, the "<TT class=character>&gt;</TT>" is 
tried immediately after the first "<TT class=character>&lt;</TT>" matches, and 
when it fails, the engine advances a character at a time, retrying the "<TT 
class=character>&gt;</TT>" at every step. This produces just the right result: 
<P>
<DIV class=verbatim><PRE>&gt;&gt;&gt; print re.match('&lt;.*?&gt;', s).group()
&lt;html&gt;
</PRE></DIV>
<P>(Note that parsing HTML or XML with regular expressions is painful. 
Quick-and-dirty patterns will handle common cases, but HTML and XML have special 
cases that will break the obvious regular expression; by the time you've written 
a regular expression that handles all of the possible cases, the patterns will 
be <I>very</I> complicated. Use an HTML or XML parser module for such tasks.) 
<P>
<H2><A name=SECTION000740000000000000000>6.4 Not Using re.VERBOSE</A> </H2>
<P>By now you've probably noticed that regular expressions are a very compact 
notation, but they're not terribly readable. REs of moderate complexity can 
become lengthy collections of backslashes, parentheses, and metacharacters, 
making them difficult to read and understand. 
<P>For such REs, specifying the <CODE>re.VERBOSE</CODE> flag when compiling the 
regular expression can be helpful, because it allows you to format the regular 
expression more clearly. 
<P>The <CODE>re.VERBOSE</CODE> flag has several effects. Whitespace in the 
regular expression that <I>isn't</I> inside a character class is ignored. This 
means that an expression such as <TT class=regexp>dog | cat</TT> is equivalent 
to the less readable <TT class=regexp>dog|cat</TT>, but <TT class=regexp>[a 
b]</TT> will still match the characters "<TT class=character>a</TT>", "<TT 
class=character>b</TT>", or a space. In addition, you can also put comments 
inside a RE; comments extend from a "<TT class=samp>#</TT>" character to the 
next newline. When used with triple-quoted strings, this enables REs to be 
formatted more neatly: 
<P>
<DIV class=verbatim><PRE>pat = re.compile(r"""
 \s*                 # Skip leading whitespace
 (?P&lt;header&gt;[^:]+)   # Header name
 \s* :               # Whitespace, and a colon
 (?P&lt;value&gt;.*?)      # The header's value -- *? used to
                     # lose the following trailing whitespace
 \s*$                # Trailing whitespace to end-of-line
""", re.VERBOSE)
</PRE></DIV>
<P>This is far more readable than: 
<P>
<DIV class=verbatim><PRE>pat = re.compile(r"\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$")
</PRE></DIV>
<P>
<H1><A name=SECTION000800000000000000000>7 Feedback</A> </H1>
<P>Regular expressions are a complicated topic. Did this document help you 
understand them? Were there parts that were unclear, or Problems you encountered 
that weren't covered here? If so, please send suggestions for improvements to 
the author. 
<P>The most complete book on regular expressions is almost certainly Jeffrey 
Friedl's <EM class=citetitle>Mastering Regular Expressions</EM>, published by 
O'Reilly. Unfortunately, it exclusively concentrates on Perl and Java's flavours 
of regular expressions, and doesn't contain any Python material at all, so it 
won't be useful as a reference for programming in Python. (The first edition 
covered Python's now-obsolete <TT class=module>regex</TT> module, which won't 
help you much.) Consider checking it out from your library. 
<P>
<H1><A name=SECTION000900000000000000000>About this document ...</A> 
</H1><STRONG>Regular Expression HOWTO</STRONG> 
<P>This document was generated using the <A 
href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000ff>LaTeX2<TT>HTML</TT></FONT></U></A> translator. </P>
<P><A href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000ff>LaTeX2<TT>HTML</TT></FONT></U></A> is Copyright ⓒ 1993, 1994, 
1995, 1996, 1997, <A href="http://cbl.leeds.ac.uk/nikos/personal.html"><U><FONT 
color=#0000ff>Nikos Drakos</FONT></U></A>, Computer Based Learning Unit, 
University of Leeds, and Copyright ⓒ 1997, 1998, <A 
href="http://www.maths.mq.edu.au/~ross/"><U><FONT color=#0000ff>Ross 
Moore</FONT></U></A>, Mathematics Department, Macquarie University, Sydney. </P>
<P>The application of <A 
href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/"><U><FONT 
color=#0000ff>LaTeX2<TT>HTML</TT></FONT></U></A> to the Python documentation has 
been heavily tailored by Fred L. Drake, Jr. Original navigation icons were 
contributed by Christopher Petrilli. </P>
<DIV class=navigation>
<P>
<HR>

<TABLE cellSpacing=2 cellPadding=0 width="100%" align=center>
  
  <TR>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD align=middle width="100%">Regular Expression HOWTO</TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD>
    <TD><IMG height=32 src="__1_04\blank.gif" 
      width=32 border=0></TD></TR></TABLE>
<HR>
<SPAN class=release-info>Release 0.05.</SPAN> </DIV><!--End of Navigation Panel--></div>
</BODY></HTML>
