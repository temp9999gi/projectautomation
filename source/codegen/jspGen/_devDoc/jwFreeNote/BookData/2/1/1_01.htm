<HTML><HEAD><META http-equiv=Content-Type content="text/html; charset=euc-kr">
<style type="text/css">
<!--
BODY,TD,SELECT,input,DIV,form,TEXTAREA,option {font-size:9pt; font-family:verdana;color:333333}
A:link {color:#4077a0;text-decoration:none;font-weight: bold}
A:visited {color:#4077a0;text-decoration:none;font-weight: bold}
A:hover{color:#990000;text-decoration:none;font-weight: bold}
--></style></HEAD>
<BODY>
<table cellSpacing=1 cellPadding=4 width=500 bgColor=#3c62c6 border=0>
  <tr>
    <td width=600>
      <div><STRONG><FONT color=#ffffff>▶제목/참고</FONT></STRONG> </div></td></tr>
  <tr bgColor=#ffffff>
    <td>
      <div></div>
      <DIV>Title: </DIV>      
      <div>&nbsp;</div>
      <DIV>&nbsp;</DIV>
      <DIV>From: </DIV>
    </td></tr></table>
<div>&nbsp;</div>
<DIV>[CVS 접근 방법] <BR>1. pserver <BR>pserver 장점 <BR>- 상대적으로 설정하기 쉽다. <BR>- 읽기 전용 
사용자(체크아웃과 갱신은 해도 변경 내용은 전송하지 못하는 사용자)를 만들 수 있다. <BR>- 익명 접근(수많은 대중에게 저장소 접근을 
허용하기 위해 오픈 소스 프로젝트에서 많이 사용하는 기능)을 지원한다. <BR>pserver 단점 <BR>- 고유한 네트워크 포트를 써야 
하는데, 많은 회사의 방화벽이 이것을 허용하지 않는다. <BR>- 패스워드 암호화는 매우 약하며, 파일 내용을 전송할 때도 암호화되지 않은 일반 
텍스트 형식으로 전송된다. <BR>- 관리에 별도의 노력을 들여야 한다. <BR><BR>2. ssh 터널 <BR>정기적으로 외부에서 접근해야 할 
때는, ssh 터널을 사용한다. <BR><BR><BR>[CVS 접근하기] <BR># :접근방법종류:사용자@서버:저장소위치 <BR>1. 
pserver <BR>export CVSROOT=:pserver:first9@cvs.openlight.org:/home/first9/cvs 
<BR><BR>2. ssh 터널 <BR>export CVS_RSH=ssh <BR>export 
CVSROOT=:ext:first9@cvs.openlight.org:/home/first9/cvs <BR><BR><BR>[CVS 저장소 만들기 
<BR>cvs -d /home/first9/cvs init <BR><BR><BR>[프로젝트 들여넣기 및 작업 환경 만들기] <BR>cvs 
import -m "프로젝트 시작" xmas xmas initial <BR>cd .. <BR>rm -rf xmas <BR># cvs 
checkout [-r 버전 번호] [-D 날짜] [-d 받을 디렉토리 이름] xmas <BR>cvs checkout xmas 
<BR><BR><BR>[최신 정보 유지하기] <BR># 마지막 체크아웃한 이후에 저장소에 추가된 새로운 디렉토리가 있을 경우, 그것을 작업 
디렉토리에 기본적으로 만들어주지는 않는다. 그러려면 -d 옵션을 붙여야 한다. <BR>cvs update -d <BR><BR><BR>[파일 및 
디렉토리 추가하기] <BR>mkdir server <BR>cvs add server <BR>cd server <BR># main.py 파일을 
만들고 코드를 작성한다. <BR>cvs add main.py <BR><BR><BR>[CVS와 바이너리] <BR># 바이너리 파일 저장소에 추가 
<BR>cvs add -kb xmas.doc <BR><BR>CVS가 영리하게 하는 일 <BR>- 매번 내용이 바뀔 때마다 전체 파일 내용을 모두 
저장하지 않고, 변경된 줄만 저장해서 모든 개정판을 다 저장하면서도 디스크 용량을 절약할 수 있다. <BR>- 운영체제마다 다른 줄 구분 글자를 
적절하게 다룰 줄 안다(특히 라인피드(\n)만 쓰는 유닉스와 라인피드와 캐리지리턴(\r\n) 글자를 모두 쓰는 DOS의 차이점). <BR>- 
특정 키워드를 대체하는 방법으로 자동으로 파일에 주석을 달아준다(권하지 않는 기능이다.). <BR>CVS가 바이너리 파일을 이렇데 다루는 경우, 
이런 기능때문에 파일이 망가지게 된다. <BR>- 개정판 사이의 차이점을 계산하기 위해 CVS가 사용하는 도구는 바이너리 파일을 대상으로 
작동하지 않는다. <BR>- 바이너리 파일에는 줄 구분 글자 같은 것이 없다. 라인피드 한 바이트가 나올 때마다 캐리지리턴 글자와 라인피드 두 
바이트로 바꿔버리면 아마 파일이 망가질 것이다. <BR>- 바이너리 파일에 어쩌다 CVS 키워드와 동일한 문자열이 포함되었다면, 이것을 확장하면 
안될 것 이다. 여기서도 파일의 형식을 망가뜨리는 일이 생긴다. <BR><BR><BR>[파일의 성격과 cvswrappers] <BR>CVS 
wrapper 기능을 사용하면 파일 이름을 가지고 특정 파일의 기본 성격을 설정할 수 있다. <BR>1. 저장소의 
CVSROOT/cvswrappers 파일에서 설정한다. <BR>2. 사용자 한 명만 대상으로 하려면 .cvswrappers 파일에서 설정한다. 
이 파일은 사용자의 홈 디렉토리에 있어야 한다. <BR>3. cvs import와 cvs update 명령을 쓸 때 -W 명령줄 옵션을 통해 
설정한다. 이 방법은 이 기능이 단 한 번만 필요할 때, 특히 기존 디렉토리 구조를 CVS에 들여오는 등의 경우에 유용하다. <BR>cvs 
import -W "*.jar -k 'b' -W "*.doc -k 'b'" -m '메시지' myproject <BR>-W 옵션 방법의 문제점은 
다음에 비슷한 것을 들여올 때 이 옵션을 쓰는 것을 잊어버리기 쉽다는 것이다. 이런 이유로 저장소의 CVSROOT 아래 저장된 
cvswrappers 파일에 영구적으로 옵션을 저장해 두고 싶을 것이다. 먼저 CVSROOT의 파일들을 체크아웃하자. <BR>cvs co 
CVSROOT <BR>이제 체크아웃된 CVSROOT 디렉토리에 들어가서 cvswrappers 파일을 수정하자. .jar과 .doc 파일에 -kb 
옵션을 더하려면, 다음과 같이 추가한다. <BR>*.jar -k 'b' <BR>*.doc -k 'b' <BR>이제 이렇게 고친 내용을 저장소에 
다시 저장한다. <BR>cvs commit -m "모든 .doc/.jar 파일을 바이너리 파일로 취급하도록" <BR>cvs release -d 
CVSROOT <BR><BR><BR>[특정 파일들을 무시하기] <BR># 해당 디렉토리 내에 특정 파일을 무시하기 위해서는 .cvsignore 
파일에 특정 파일을 추가한다. <BR>.cvsignore 파일: <BR>Dummy.java <BR>*.class <BR>*.log <BR>cvs 
add .cvsignore <BR>cvs commit -m "Dummy, 기록, class 파일을 무시한다" .cvsignore 
<BR><BR><BR>[파일 이름 바꾸기] <BR>cvs -q update -d <BR>mv main.py xmas_main.py <BR>cvs 
remove main.py <BR>cvs add xmas_main.py <BR>cvs commit -m "main.py의 이름을 
xmas_main.py로 바꿈" <BR># 부작용: 이름을 바꾼 파일의 개정판 번호가 1.1부터 다시 시작한다. 이전 개정 기록은 그대로 
main.py라는 이름 아래 남아 있다. <BR># 이와 유사하게 파일이 더 이상 작업 공간에 없더라도 CVS에게 그 파일의 상태를 물어볼 수 
있다. <BR>cvs status main.py <BR># 이제 1.6 개정판(존재했던 마지막 버전)을 체크아웃해보자. <BR>cvs 
update -r1.6 main.py <BR>cvs status main.py <BR># 파일은 성공적으로 살아났다. 하지만 이것은 최신 파일인 
작업 공간에서 외로이 떨어진 시대 착오적인 파일이므로, cvs update의 -A 옵션(clearAll)을 써서 정리해 주자. <BR>cvs 
update -A <BR># 나중에 새로운 파일을 만들어 지운 파일과 똑같은 main.py라는 이름을 붙이면 어떤 일이 생길까? CVS에게는 
전혀 문제가 되지 않는다. CVS는 그 파일에 다음 개정 번호(1.8)를 주고 그냥 저장소에 추가한다. 나중에 1.7 이전의 개정판을 CVS에게 
요청하면, 옛날 파일을 받을 것이다. 1.7 이후의 개정판을 요청하면 새로운 파일을 받을 것이다. <BR><BR><BR>[디렉토리 이름 바꾸기] 
<BR>1. 새 디렉토리를 만든다. <BR>2. 새 디렉토리를 CVS에 추가한다. <BR>3. 옛날 디렉토리에 새 디렉토리 파일을 옮긴다. 
<BR>4. 옛날 디렉토리에서 cvs remove를 써서 파일이 더 이상 여기 없다고 CVS에게 알려준다. <BR>5. 새 디렉토리에서 cvs 
add를 사용해 옮겨 온 파일들을 저장소에 추가한다. <BR>6. 변경 내용을 전송하고, -P 옵션을 붙여 cvs update를 해서 작업 
공간에서 옛날 디렉토리를 지운다. (-P (Prune)옵션은 지역 작업 공간에서 빈 디렉토리를 모두 제거한다.) <BR><BR>mkdir lib 
<BR>cvs add lib <BR>mv lib/util.py library <BR>cvs remove library/util.py 
<BR>cvs add lib/util.py <BR>cvs commit -m "library/의 이름을 lib/로 바꿈" <BR>cvs 
update -P <BR><BR># 사소한 문제가 있는데, 나중에 누군가 와서 프로젝트를 처음으로 체크아웃하면, util.java 파일은 제대로 
lib/안에 나타나지만, 지워진 파일을 담는 장소로 빈 디렉토리인 library/도 생기게 된다. 이 디렉토리는 cvs update에 -P 
옵션을 붙여 실행하면 지울 수 있다. 아니면 처음에 체크아웃할 때 -P 옵션을 붙여도 된다. <BR><BR><BR>[차이점 보기] <BR># 
최신과 비교하기 <BR>cvs diff -rHEAD main.py <BR><BR># 버전끼리 비교하기 <BR>cvs diff -r1.2 
-r1.3 main.py <BR><BR># 전후 맥락과 같이 보여주기 <BR>cvs diff -c main.py <BR><BR># 지역 버전의 
내용과 저장소 버전의 내용을 나란히 표시한다. <BR>cvs diff --side-by-side index.html 
<BR><BR><BR>[차이점 정보와 패치 파일] <BR># -u 옵션 (통합 차이점 정보(Unified diff)) <BR>cvs diff 
-u &gt; diff.list <BR>patch -p0 &lt; diff.list <BR><BR><BR>[충돌 해결하기] <BR>첫번째, 
여러분이 고친 것을 버리고 저장소 버전을 갱신받아 여러분의 코드를 적절하게 다시 넣은 후 커밋한다. <BR>두번째, 충돌 표시부분을 제거하고 
적절하게 수정한 후 커밋한다. <BR><BR><BR>[변경 기록 조사하기] <BR>cvs log main.py <BR><BR>#두 날짜 사이의 
변경 기록을 보여준다. <BR>cvs log -d "2 days ago" -d today <BR><BR><BR>[줄 단위 기록] <BR>cvs 
annotate main.py <BR><BR><BR>[변경 되돌리기] <BR>cvs update -j1.4 -j1.3 main.py 
<BR><BR><BR>[더 심각한 변화를 되돌리기] <BR># -j 옵션에 꼬리표 이름을 사용하는 것이다. <BR>cvs update -j 
after_change -j before_change <BR><BR><BR>[꼬리표와 브랜치 사용하기] <BR>1. 릴리즈 브랜치 
<BR>RB-릴리즈 번호 <BR><BR>2. 릴리즈 <BR>REL-릴리즈 번호 <BR><BR>3. 버그 해결 직전 <BR>PRE-추적 번호 
<BR><BR>4. 버그 해결 직후 <BR>POST-추적 번호 <BR>5. 개발자 실험 <BR>TRY-개발자 이름 약자-날짜 <BR><BR>1. 
릴리즈 브랜치 만들고 작업하기 <BR>cvs commit -m " " <BR>cvs rtag -b BR_1_0 project <BR># 릴리즈 
브랜치에서 작업하기 <BR>cd .. <BR>cvs co -r BR_1_0 -d br1.0 project <BR>cd br1.0 <BR># 
편집한다. <BR>cvs commit -m "에러 메시지를 정리했음" <BR><BR>2. 프로젝트 릴리즈하기 <BR>cvs update 
<BR># 테스트 돌린다. <BR>cvs commit -m "..." <BR>cvs tag REL_1_0 <BR>cvs co -r REL_1_0 
-d rel1.0 project <BR><BR>3. 릴리즈 브랜치에서 버그 고치기 <BR>cvs co -r BR_1_0 -d br1.0 
project <BR>cd br1.0 <BR>cvs tag PRE_1234 <BR># 테스트를 작정하고, 문제를 고치고, 검증한다. 
<BR>cvs commit -m "PRE1234를 고침" <BR>cvs tag POST_1234 <BR># 릴리즈 브랜치로부터 해결책을 
병합한다. <BR>cd ../project <BR>cvs update <BR>cvs update -j PRE_1234 -j POST_1234 
<BR># 테스트 <BR>cvs commit -m "PRE1234의 해결책을 BR1.0으로부터 가져와 적용함" <BR><BR>4. 개발자의 
실험용 브랜치 <BR>cvs commit -m " " <BR>cvs rtag -b TRY_DT_030925 project <BR># 실험용 
코드로 작업하기 <BR>cvs co -r TRY_DT_092503 -d proj_exp project <BR>cd proj_exp <BR># 
실험용 브랜치를 병합하기 <BR>cd proj_exp <BR>cvs commit -m "변경 종료" <BR>cd .. <BR>cd project 
<BR>cvs update -j TRY_DT_092503 <BR><BR><BR>[상위 프로젝트 만들기] <BR>- 이 저장소의 최상단을 
체크아웃한다. 그러려면 일반적인 cvs checkout 명령을 쓰되, 여기에 -d와 -l 옵션을 추가하고 프로젝트 이름으로는 특별한 의미가 있는 
"."(점)을 지정해야 한다. -d 옵션은 작업 공간 디렉토리 이름을 지정하기 위해 사용하고, -l 옵션은 CVS에게 저장소의 내용물을 모두 
체크아웃하지 말고 오직 저장소의 최상위 디렉토리들만 작업 공간에 만들라고 지시하기 위해 사용한다. <BR>- 체크아웃된 작업 공간 안에서 새로 
추가할 프로젝트 디렉토리를 만들고, 이 디렉토리를 저장소에 추가하기 위해 cvs add 명령을 사용한다. <BR>- 체크아웃된 전체 저장소를 
해제(release)한다(전체 저장소를 다 지역 작업 공간에 가지고 있을 필요가 없기 때문이다). <BR>- 다시 체크아웃하되, 이번에는 방금 
만든 프로젝트의 이름을 가지고 체크아웃한다. <BR><BR>cvs chechout -l -d tmp . <BR>cd tmp <BR>mkdir 
new_project <BR>cvs add new_project <BR>cd .. <BR>cd release -d tmp <BR>cvs 
checkout new_project <BR>cd new_project <BR><BR><BR>[CVS 모듈] <BR>cvs co CVSROOT 
<BR>vi modules <BR><BR>1. 별명 모듈 <BR>client -a proj1/client <BR>xml -a 
library/xml <BR>date -a library/date <BR>clientall -a client xml date <BR>(= 
clientall -a proj1/client library/xml library/date) <BR># -a는 alias <BR><BR>2. 
일반 모듈 및 &amp; 모듈 <BR>courses PP/doc/Courses <BR>halfruby 
PP/doc/Courses/HalfDayRuby <BR>allruby &amp;courses &amp;halfruby <BR># halfruby 
모듈을 체크아웃하면 루비 강의 자료 디렉토리가 halfruby라는 이름으로 나타난다. <BR><BR><BR>[하위 프로젝트를 나누는 쉬운 방법] 
<BR>- 빌드 환경을 손수 맞춰 준다. <BR>- 환경 변수를 사용한다. <BR>- 상대 경로를 사용한다. <BR><BR><BR>[충고] 
<BR>공유 파일의 문서 양식을 제멋대로 바꾸지 말라. <BR></DIV>
</BODY></HTML>
